/*
API Documentation

Source of truth and network automation platform

API version: 2.3.2 (2.3)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nautobot

import (
	"time"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IpamAPIService IpamAPI service
type IpamAPIService service

type ApiIpamIpAddressToInterfaceBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamIpAddressToInterfaceBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceBulkDestroyExecute(r)
}

/*
IpamIpAddressToInterfaceBulkDestroy Method for IpamIpAddressToInterfaceBulkDestroy

Destroy a list of IP Address Assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressToInterfaceBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkDestroy(ctx context.Context) ApiIpamIpAddressToInterfaceBulkDestroyRequest {
	return ApiIpamIpAddressToInterfaceBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkDestroyExecute(r ApiIpamIpAddressToInterfaceBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableIPAddressToInterfaceRequest *[]PatchedBulkWritableIPAddressToInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest) PatchedBulkWritableIPAddressToInterfaceRequest(patchedBulkWritableIPAddressToInterfaceRequest []PatchedBulkWritableIPAddressToInterfaceRequest) ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest {
	r.patchedBulkWritableIPAddressToInterfaceRequest = &patchedBulkWritableIPAddressToInterfaceRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest) Execute() ([]IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressToInterfaceBulkPartialUpdate Method for IpamIpAddressToInterfaceBulkPartialUpdate

Partial update a list of IP Address Assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest {
	return ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkPartialUpdateExecute(r ApiIpamIpAddressToInterfaceBulkPartialUpdateRequest) ([]IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableIPAddressToInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableIPAddressToInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableIPAddressToInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableIPAddressToInterfaceRequest *[]BulkWritableIPAddressToInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceBulkUpdateRequest) BulkWritableIPAddressToInterfaceRequest(bulkWritableIPAddressToInterfaceRequest []BulkWritableIPAddressToInterfaceRequest) ApiIpamIpAddressToInterfaceBulkUpdateRequest {
	r.bulkWritableIPAddressToInterfaceRequest = &bulkWritableIPAddressToInterfaceRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceBulkUpdateRequest) Execute() ([]IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceBulkUpdateExecute(r)
}

/*
IpamIpAddressToInterfaceBulkUpdate Method for IpamIpAddressToInterfaceBulkUpdate

Update a list of IP Address Assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressToInterfaceBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkUpdate(ctx context.Context) ApiIpamIpAddressToInterfaceBulkUpdateRequest {
	return ApiIpamIpAddressToInterfaceBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfaceBulkUpdateExecute(r ApiIpamIpAddressToInterfaceBulkUpdateRequest) ([]IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableIPAddressToInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableIPAddressToInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableIPAddressToInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	iPAddressToInterfaceRequest *IPAddressToInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceCreateRequest) IPAddressToInterfaceRequest(iPAddressToInterfaceRequest IPAddressToInterfaceRequest) ApiIpamIpAddressToInterfaceCreateRequest {
	r.iPAddressToInterfaceRequest = &iPAddressToInterfaceRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceCreateRequest) Execute() (*IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceCreateExecute(r)
}

/*
IpamIpAddressToInterfaceCreate Method for IpamIpAddressToInterfaceCreate

Create one or more IP Address Assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressToInterfaceCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceCreate(ctx context.Context) ApiIpamIpAddressToInterfaceCreateRequest {
	return ApiIpamIpAddressToInterfaceCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfaceCreateExecute(r ApiIpamIpAddressToInterfaceCreateRequest) (*IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressToInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressToInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressToInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceDestroyExecute(r)
}

/*
IpamIpAddressToInterfaceDestroy Method for IpamIpAddressToInterfaceDestroy

Destroy a IP Address Assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfaceDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceDestroy(ctx context.Context, id string) ApiIpamIpAddressToInterfaceDestroyRequest {
	return ApiIpamIpAddressToInterfaceDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressToInterfaceDestroyExecute(r ApiIpamIpAddressToInterfaceDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	created *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interface_ *[]string
	interfaceIsnull *bool
	interfaceN *[]string
	ipAddress *[]string
	ipAddressN *[]string
	isDefault *bool
	isDestination *bool
	isPreferred *bool
	isPrimary *bool
	isSecondary *bool
	isSource *bool
	isStandby *bool
	lastUpdated *[]time.Time
	limit *int32
	offset *int32
	q *string
	sort *string
	vmInterface *[]string
	vmInterfaceIsnull *bool
	vmInterfaceN *[]string
	depth *int32
}

func (r ApiIpamIpAddressToInterfaceListRequest) Created(created []time.Time) ApiIpamIpAddressToInterfaceListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamIpAddressToInterfaceListRequest) Id(id []string) ApiIpamIpAddressToInterfaceListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdIc(idIc []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdIe(idIe []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdIew(idIew []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdIre(idIre []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdIsw(idIsw []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdN(idN []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNic(idNic []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNie(idNie []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNiew(idNiew []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNire(idNire []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNisw(idNisw []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdNre(idNre []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IdRe(idRe []string) ApiIpamIpAddressToInterfaceListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) Interface_(interface_ []string) ApiIpamIpAddressToInterfaceListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name or ID) is null
func (r ApiIpamIpAddressToInterfaceListRequest) InterfaceIsnull(interfaceIsnull bool) ApiIpamIpAddressToInterfaceListRequest {
	r.interfaceIsnull = &interfaceIsnull
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressToInterfaceListRequest {
	r.interfaceN = &interfaceN
	return r
}

// IP Address (ID)
func (r ApiIpamIpAddressToInterfaceListRequest) IpAddress(ipAddress []string) ApiIpamIpAddressToInterfaceListRequest {
	r.ipAddress = &ipAddress
	return r
}

// Exclude IP Address (ID)
func (r ApiIpamIpAddressToInterfaceListRequest) IpAddressN(ipAddressN []string) ApiIpamIpAddressToInterfaceListRequest {
	r.ipAddressN = &ipAddressN
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsDefault(isDefault bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isDefault = &isDefault
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsDestination(isDestination bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isDestination = &isDestination
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsPreferred(isPreferred bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isPreferred = &isPreferred
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsPrimary(isPrimary bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isPrimary = &isPrimary
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsSecondary(isSecondary bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isSecondary = &isSecondary
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsSource(isSource bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isSource = &isSource
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) IsStandby(isStandby bool) ApiIpamIpAddressToInterfaceListRequest {
	r.isStandby = &isStandby
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpAddressToInterfaceListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressToInterfaceListRequest) Limit(limit int32) ApiIpamIpAddressToInterfaceListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressToInterfaceListRequest) Offset(offset int32) ApiIpamIpAddressToInterfaceListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamIpAddressToInterfaceListRequest) Q(q string) ApiIpamIpAddressToInterfaceListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpAddressToInterfaceListRequest) Sort(sort string) ApiIpamIpAddressToInterfaceListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) VmInterface(vmInterface []string) ApiIpamIpAddressToInterfaceListRequest {
	r.vmInterface = &vmInterface
	return r
}

// VM Interface (name or ID) is null
func (r ApiIpamIpAddressToInterfaceListRequest) VmInterfaceIsnull(vmInterfaceIsnull bool) ApiIpamIpAddressToInterfaceListRequest {
	r.vmInterfaceIsnull = &vmInterfaceIsnull
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) VmInterfaceN(vmInterfaceN []string) ApiIpamIpAddressToInterfaceListRequest {
	r.vmInterfaceN = &vmInterfaceN
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressToInterfaceListRequest) Depth(depth int32) ApiIpamIpAddressToInterfaceListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressToInterfaceListRequest) Execute() (*PaginatedIPAddressToInterfaceList, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceListExecute(r)
}

/*
IpamIpAddressToInterfaceList Method for IpamIpAddressToInterfaceList

Retrieve a list of IP Address Assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressToInterfaceListRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceList(ctx context.Context) ApiIpamIpAddressToInterfaceListRequest {
	return ApiIpamIpAddressToInterfaceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressToInterfaceList
func (a *IpamAPIService) IpamIpAddressToInterfaceListExecute(r ApiIpamIpAddressToInterfaceListRequest) (*PaginatedIPAddressToInterfaceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressToInterfaceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "form", "multi")
		}
	}
	if r.interfaceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface__isnull", r.interfaceIsnull, "form", "")
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "form", "multi")
		}
	}
	if r.ipAddress != nil {
		t := *r.ipAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", t, "form", "multi")
		}
	}
	if r.ipAddressN != nil {
		t := *r.ipAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", t, "form", "multi")
		}
	}
	if r.isDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_default", r.isDefault, "form", "")
	}
	if r.isDestination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_destination", r.isDestination, "form", "")
	}
	if r.isPreferred != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_preferred", r.isPreferred, "form", "")
	}
	if r.isPrimary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_primary", r.isPrimary, "form", "")
	}
	if r.isSecondary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_secondary", r.isSecondary, "form", "")
	}
	if r.isSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_source", r.isSource, "form", "")
	}
	if r.isStandby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_standby", r.isStandby, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.vmInterface != nil {
		t := *r.vmInterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interface", t, "form", "multi")
		}
	}
	if r.vmInterfaceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interface__isnull", r.vmInterfaceIsnull, "form", "")
	}
	if r.vmInterfaceN != nil {
		t := *r.vmInterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interface__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamIpAddressToInterfaceNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceNotesCreateExecute(r)
}

/*
IpamIpAddressToInterfaceNotesCreate Method for IpamIpAddressToInterfaceNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfaceNotesCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceNotesCreate(ctx context.Context, id string) ApiIpamIpAddressToInterfaceNotesCreateRequest {
	return ApiIpamIpAddressToInterfaceNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamIpAddressToInterfaceNotesCreateExecute(r ApiIpamIpAddressToInterfaceNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamIpAddressToInterfaceNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressToInterfaceNotesListRequest) Limit(limit int32) ApiIpamIpAddressToInterfaceNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressToInterfaceNotesListRequest) Offset(offset int32) ApiIpamIpAddressToInterfaceNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressToInterfaceNotesListRequest) Depth(depth int32) ApiIpamIpAddressToInterfaceNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressToInterfaceNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceNotesListExecute(r)
}

/*
IpamIpAddressToInterfaceNotesList Method for IpamIpAddressToInterfaceNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfaceNotesListRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceNotesList(ctx context.Context, id string) ApiIpamIpAddressToInterfaceNotesListRequest {
	return ApiIpamIpAddressToInterfaceNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamIpAddressToInterfaceNotesListExecute(r ApiIpamIpAddressToInterfaceNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfacePartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedIPAddressToInterfaceRequest *PatchedIPAddressToInterfaceRequest
}

func (r ApiIpamIpAddressToInterfacePartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfacePartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfacePartialUpdateRequest) PatchedIPAddressToInterfaceRequest(patchedIPAddressToInterfaceRequest PatchedIPAddressToInterfaceRequest) ApiIpamIpAddressToInterfacePartialUpdateRequest {
	r.patchedIPAddressToInterfaceRequest = &patchedIPAddressToInterfaceRequest
	return r
}

func (r ApiIpamIpAddressToInterfacePartialUpdateRequest) Execute() (*IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfacePartialUpdateExecute(r)
}

/*
IpamIpAddressToInterfacePartialUpdate Method for IpamIpAddressToInterfacePartialUpdate

Partial update a IP Address Assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfacePartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfacePartialUpdate(ctx context.Context, id string) ApiIpamIpAddressToInterfacePartialUpdateRequest {
	return ApiIpamIpAddressToInterfacePartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfacePartialUpdateExecute(r ApiIpamIpAddressToInterfacePartialUpdateRequest) (*IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfacePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedIPAddressToInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamIpAddressToInterfaceRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressToInterfaceRetrieveRequest) Depth(depth int32) ApiIpamIpAddressToInterfaceRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressToInterfaceRetrieveRequest) Execute() (*IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceRetrieveExecute(r)
}

/*
IpamIpAddressToInterfaceRetrieve Method for IpamIpAddressToInterfaceRetrieve

Retrieve a IP Address Assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfaceRetrieveRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceRetrieve(ctx context.Context, id string) ApiIpamIpAddressToInterfaceRetrieveRequest {
	return ApiIpamIpAddressToInterfaceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfaceRetrieveExecute(r ApiIpamIpAddressToInterfaceRetrieveRequest) (*IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressToInterfaceUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	iPAddressToInterfaceRequest *IPAddressToInterfaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressToInterfaceUpdateRequest) IPAddressToInterfaceRequest(iPAddressToInterfaceRequest IPAddressToInterfaceRequest) ApiIpamIpAddressToInterfaceUpdateRequest {
	r.iPAddressToInterfaceRequest = &iPAddressToInterfaceRequest
	return r
}

func (r ApiIpamIpAddressToInterfaceUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressToInterfaceUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressToInterfaceUpdateRequest) Execute() (*IPAddressToInterface, *http.Response, error) {
	return r.ApiService.IpamIpAddressToInterfaceUpdateExecute(r)
}

/*
IpamIpAddressToInterfaceUpdate Method for IpamIpAddressToInterfaceUpdate

Update a IP Address Assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP Address Assignment.
 @return ApiIpamIpAddressToInterfaceUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressToInterfaceUpdate(ctx context.Context, id string) ApiIpamIpAddressToInterfaceUpdateRequest {
	return ApiIpamIpAddressToInterfaceUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressToInterface
func (a *IpamAPIService) IpamIpAddressToInterfaceUpdateExecute(r ApiIpamIpAddressToInterfaceUpdateRequest) (*IPAddressToInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressToInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressToInterfaceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-address-to-interface/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressToInterfaceRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressToInterfaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressToInterfaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamIpAddressesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamIpAddressesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkDestroyExecute(r)
}

/*
IpamIpAddressesBulkDestroy Method for IpamIpAddressesBulkDestroy

Destroy a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkDestroy(ctx context.Context) ApiIpamIpAddressesBulkDestroyRequest {
	return ApiIpamIpAddressesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesBulkDestroyExecute(r ApiIpamIpAddressesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableIPAddressRequest *[]PatchedBulkWritableIPAddressRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) PatchedBulkWritableIPAddressRequest(patchedBulkWritableIPAddressRequest []PatchedBulkWritableIPAddressRequest) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.patchedBulkWritableIPAddressRequest = &patchedBulkWritableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

Partial update a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest {
	return ApiIpamIpAddressesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableIPAddressRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableIPAddressRequest *[]BulkWritableIPAddressRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesBulkUpdateRequest) BulkWritableIPAddressRequest(bulkWritableIPAddressRequest []BulkWritableIPAddressRequest) ApiIpamIpAddressesBulkUpdateRequest {
	r.bulkWritableIPAddressRequest = &bulkWritableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkUpdateExecute(r)
}

/*
IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

Update a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest {
	return ApiIpamIpAddressesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableIPAddressRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	iPAddressRequest *IPAddressRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesCreateRequest) IPAddressRequest(iPAddressRequest IPAddressRequest) ApiIpamIpAddressesCreateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesCreateExecute(r)
}

/*
IpamIpAddressesCreate Method for IpamIpAddressesCreate

Create one or more IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest {
	return ApiIpamIpAddressesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesDestroyExecute(r)
}

/*
IpamIpAddressesDestroy Method for IpamIpAddressesDestroy

Destroy a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesDestroy(ctx context.Context, id string) ApiIpamIpAddressesDestroyRequest {
	return ApiIpamIpAddressesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesDestroyExecute(r ApiIpamIpAddressesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	address *[]string
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	device *[]string
	deviceId *[]string
	dnsName *[]string
	dnsNameIc *[]string
	dnsNameIe *[]string
	dnsNameIew *[]string
	dnsNameIre *[]string
	dnsNameIsw *[]string
	dnsNameN *[]string
	dnsNameNic *[]string
	dnsNameNie *[]string
	dnsNameNiew *[]string
	dnsNameNire *[]string
	dnsNameNisw *[]string
	dnsNameNre *[]string
	dnsNameRe *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasInterfaceAssignments *bool
	hasNatInside *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interfaces *[]string
	interfacesIsnull *bool
	interfacesN *[]string
	ipVersion *int32
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	maskLength *[]int32
	maskLengthGt *[]int32
	maskLengthGte *[]int32
	maskLengthLt *[]int32
	maskLengthLte *[]int32
	maskLengthN *[]int32
	namespace *[]string
	namespaceN *[]string
	natInside *[]string
	natInsideIsnull *bool
	natInsideN *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	prefix *[]string
	presentInVrf *string
	presentInVrfId *string
	q *string
	role *[]string
	roleIsnull *bool
	roleN *string
	sort *string
	status *[]string
	statusN *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	virtualMachine *[]string
	virtualMachineId *[]string
	vmInterfaces *[]string
	vmInterfacesIsnull *bool
	vmInterfacesN *[]string
	vrfs *[]string
	vrfsIsnull *bool
	vrfsN *[]string
	depth *int32
}

// Address
func (r ApiIpamIpAddressesListRequest) Address(address []string) ApiIpamIpAddressesListRequest {
	r.address = &address
	return r
}

func (r ApiIpamIpAddressesListRequest) Contacts(contacts []string) ApiIpamIpAddressesListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamIpAddressesListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamIpAddressesListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamIpAddressesListRequest) ContactsN(contactsN string) ApiIpamIpAddressesListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamIpAddressesListRequest) Created(created []time.Time) ApiIpamIpAddressesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGt(createdGt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGte(createdGte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedIsnull(createdIsnull bool) ApiIpamIpAddressesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLt(createdLt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLte(createdLte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedN(createdN []time.Time) ApiIpamIpAddressesListRequest {
	r.createdN = &createdN
	return r
}

// Device (name)
func (r ApiIpamIpAddressesListRequest) Device(device []string) ApiIpamIpAddressesListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiIpamIpAddressesListRequest) DeviceId(deviceId []string) ApiIpamIpAddressesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsName(dnsName []string) ApiIpamIpAddressesListRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIre(dnsNameIre []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIre = &dnsNameIre
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesListRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNire(dnsNameNire []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNire = &dnsNameNire
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNre(dnsNameNre []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNre = &dnsNameNre
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameRe(dnsNameRe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameRe = &dnsNameRe
	return r
}

func (r ApiIpamIpAddressesListRequest) DynamicGroups(dynamicGroups []string) ApiIpamIpAddressesListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamIpAddressesListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamIpAddressesListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamIpAddressesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesListRequest {
	r.format = &format
	return r
}

// Has Interface Assignments
func (r ApiIpamIpAddressesListRequest) HasInterfaceAssignments(hasInterfaceAssignments bool) ApiIpamIpAddressesListRequest {
	r.hasInterfaceAssignments = &hasInterfaceAssignments
	return r
}

// Has NAT Inside
func (r ApiIpamIpAddressesListRequest) HasNatInside(hasNatInside bool) ApiIpamIpAddressesListRequest {
	r.hasNatInside = &hasNatInside
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamIpAddressesListRequest) Id(id []string) ApiIpamIpAddressesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIc(idIc []string) ApiIpamIpAddressesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIe(idIe []string) ApiIpamIpAddressesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIew(idIew []string) ApiIpamIpAddressesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIre(idIre []string) ApiIpamIpAddressesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIsw(idIsw []string) ApiIpamIpAddressesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) IdN(idN []string) ApiIpamIpAddressesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNic(idNic []string) ApiIpamIpAddressesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNie(idNie []string) ApiIpamIpAddressesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNiew(idNiew []string) ApiIpamIpAddressesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNire(idNire []string) ApiIpamIpAddressesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNisw(idNisw []string) ApiIpamIpAddressesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNre(idNre []string) ApiIpamIpAddressesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamIpAddressesListRequest) IdRe(idRe []string) ApiIpamIpAddressesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamIpAddressesListRequest) Interfaces(interfaces []string) ApiIpamIpAddressesListRequest {
	r.interfaces = &interfaces
	return r
}

// Interfaces (ID or name) is null
func (r ApiIpamIpAddressesListRequest) InterfacesIsnull(interfacesIsnull bool) ApiIpamIpAddressesListRequest {
	r.interfacesIsnull = &interfacesIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) InterfacesN(interfacesN []string) ApiIpamIpAddressesListRequest {
	r.interfacesN = &interfacesN
	return r
}

func (r ApiIpamIpAddressesListRequest) IpVersion(ipVersion int32) ApiIpamIpAddressesListRequest {
	r.ipVersion = &ipVersion
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamIpAddressesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesListRequest) Limit(limit int32) ApiIpamIpAddressesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLength(maskLength []int32) ApiIpamIpAddressesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthGt(maskLengthGt []int32) ApiIpamIpAddressesListRequest {
	r.maskLengthGt = &maskLengthGt
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthGte(maskLengthGte []int32) ApiIpamIpAddressesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthLt(maskLengthLt []int32) ApiIpamIpAddressesListRequest {
	r.maskLengthLt = &maskLengthLt
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthLte(maskLengthLte []int32) ApiIpamIpAddressesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthN(maskLengthN []int32) ApiIpamIpAddressesListRequest {
	r.maskLengthN = &maskLengthN
	return r
}

func (r ApiIpamIpAddressesListRequest) Namespace(namespace []string) ApiIpamIpAddressesListRequest {
	r.namespace = &namespace
	return r
}

func (r ApiIpamIpAddressesListRequest) NamespaceN(namespaceN []string) ApiIpamIpAddressesListRequest {
	r.namespaceN = &namespaceN
	return r
}

// NAT (Inside)
func (r ApiIpamIpAddressesListRequest) NatInside(natInside []string) ApiIpamIpAddressesListRequest {
	r.natInside = &natInside
	return r
}

func (r ApiIpamIpAddressesListRequest) NatInsideIsnull(natInsideIsnull bool) ApiIpamIpAddressesListRequest {
	r.natInsideIsnull = &natInsideIsnull
	return r
}

// NAT (Inside)
func (r ApiIpamIpAddressesListRequest) NatInsideN(natInsideN []string) ApiIpamIpAddressesListRequest {
	r.natInsideN = &natInsideN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesListRequest) Offset(offset int32) ApiIpamIpAddressesListRequest {
	r.offset = &offset
	return r
}

// Parent prefix
func (r ApiIpamIpAddressesListRequest) Parent(parent []string) ApiIpamIpAddressesListRequest {
	r.parent = &parent
	return r
}

// Parent prefix is null
func (r ApiIpamIpAddressesListRequest) ParentIsnull(parentIsnull bool) ApiIpamIpAddressesListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

// Exclude Parent prefix
func (r ApiIpamIpAddressesListRequest) ParentN(parentN []string) ApiIpamIpAddressesListRequest {
	r.parentN = &parentN
	return r
}

// Contained in prefix
func (r ApiIpamIpAddressesListRequest) Prefix(prefix []string) ApiIpamIpAddressesListRequest {
	r.prefix = &prefix
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// VRF (ID)
func (r ApiIpamIpAddressesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesListRequest) Q(q string) ApiIpamIpAddressesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamIpAddressesListRequest) Role(role []string) ApiIpamIpAddressesListRequest {
	r.role = &role
	return r
}

// Role (name or ID) is null
func (r ApiIpamIpAddressesListRequest) RoleIsnull(roleIsnull bool) ApiIpamIpAddressesListRequest {
	r.roleIsnull = &roleIsnull
	return r
}

// Exclude Role (name or ID)
func (r ApiIpamIpAddressesListRequest) RoleN(roleN string) ApiIpamIpAddressesListRequest {
	r.roleN = &roleN
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpAddressesListRequest) Sort(sort string) ApiIpamIpAddressesListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamIpAddressesListRequest) Status(status []string) ApiIpamIpAddressesListRequest {
	r.status = &status
	return r
}

// Exclude Status (name or ID)
func (r ApiIpamIpAddressesListRequest) StatusN(statusN string) ApiIpamIpAddressesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesListRequest) Tags(tags []string) ApiIpamIpAddressesListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamIpAddressesListRequest) TagsIsnull(tagsIsnull bool) ApiIpamIpAddressesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) TagsN(tagsN []string) ApiIpamIpAddressesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamIpAddressesListRequest) Teams(teams []string) ApiIpamIpAddressesListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamIpAddressesListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamIpAddressesListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamIpAddressesListRequest) TeamsN(teamsN string) ApiIpamIpAddressesListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamIpAddressesListRequest) Tenant(tenant []string) ApiIpamIpAddressesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (name or ID) is null
func (r ApiIpamIpAddressesListRequest) TenantIsnull(tenantIsnull bool) ApiIpamIpAddressesListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantN(tenantN []string) ApiIpamIpAddressesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (name or ID) is null
func (r ApiIpamIpAddressesListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiIpamIpAddressesListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamIpAddressesListRequest) TenantId(tenantId []*string) ApiIpamIpAddressesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead) is null
func (r ApiIpamIpAddressesListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiIpamIpAddressesListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Exclude Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamIpAddressesListRequest) TenantIdN(tenantIdN []*string) ApiIpamIpAddressesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Type_(type_ []string) ApiIpamIpAddressesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeIc(typeIc []string) ApiIpamIpAddressesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeIe(typeIe []string) ApiIpamIpAddressesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeIew(typeIew []string) ApiIpamIpAddressesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeIre(typeIre []string) ApiIpamIpAddressesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeIsw(typeIsw []string) ApiIpamIpAddressesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeN(typeN []string) ApiIpamIpAddressesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNic(typeNic []string) ApiIpamIpAddressesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNie(typeNie []string) ApiIpamIpAddressesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNiew(typeNiew []string) ApiIpamIpAddressesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNire(typeNire []string) ApiIpamIpAddressesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNisw(typeNisw []string) ApiIpamIpAddressesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeNre(typeNre []string) ApiIpamIpAddressesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiIpamIpAddressesListRequest) TypeRe(typeRe []string) ApiIpamIpAddressesListRequest {
	r.typeRe = &typeRe
	return r
}

// Virtual machine (name)
func (r ApiIpamIpAddressesListRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (ID)
func (r ApiIpamIpAddressesListRequest) VirtualMachineId(virtualMachineId []string) ApiIpamIpAddressesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiIpamIpAddressesListRequest) VmInterfaces(vmInterfaces []string) ApiIpamIpAddressesListRequest {
	r.vmInterfaces = &vmInterfaces
	return r
}

// VM interfaces (ID or name) is null
func (r ApiIpamIpAddressesListRequest) VmInterfacesIsnull(vmInterfacesIsnull bool) ApiIpamIpAddressesListRequest {
	r.vmInterfacesIsnull = &vmInterfacesIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) VmInterfacesN(vmInterfacesN []string) ApiIpamIpAddressesListRequest {
	r.vmInterfacesN = &vmInterfacesN
	return r
}

func (r ApiIpamIpAddressesListRequest) Vrfs(vrfs []string) ApiIpamIpAddressesListRequest {
	r.vrfs = &vrfs
	return r
}

// VRF (ID or RD) is null
func (r ApiIpamIpAddressesListRequest) VrfsIsnull(vrfsIsnull bool) ApiIpamIpAddressesListRequest {
	r.vrfsIsnull = &vrfsIsnull
	return r
}

func (r ApiIpamIpAddressesListRequest) VrfsN(vrfsN []string) ApiIpamIpAddressesListRequest {
	r.vrfsN = &vrfsN
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressesListRequest) Depth(depth int32) ApiIpamIpAddressesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressesListRequest) Execute() (*PaginatedIPAddressList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesListExecute(r)
}

/*
IpamIpAddressesList Method for IpamIpAddressesList

Retrieve a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesListRequest
*/
func (a *IpamAPIService) IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest {
	return ApiIpamIpAddressesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressList
func (a *IpamAPIService) IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*PaginatedIPAddressList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address", t, "form", "multi")
		}
	}
	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "form", "multi")
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", t, "form", "multi")
		}
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", t, "form", "multi")
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", t, "form", "multi")
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", t, "form", "multi")
		}
	}
	if r.dnsNameIre != nil {
		t := *r.dnsNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ire", t, "form", "multi")
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", t, "form", "multi")
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", t, "form", "multi")
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", t, "form", "multi")
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", t, "form", "multi")
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", t, "form", "multi")
		}
	}
	if r.dnsNameNire != nil {
		t := *r.dnsNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nire", t, "form", "multi")
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", t, "form", "multi")
		}
	}
	if r.dnsNameNre != nil {
		t := *r.dnsNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nre", t, "form", "multi")
		}
	}
	if r.dnsNameRe != nil {
		t := *r.dnsNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__re", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.hasInterfaceAssignments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_interface_assignments", r.hasInterfaceAssignments, "form", "")
	}
	if r.hasNatInside != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_nat_inside", r.hasNatInside, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.interfaces != nil {
		t := *r.interfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces", t, "form", "multi")
		}
	}
	if r.interfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__isnull", r.interfacesIsnull, "form", "")
	}
	if r.interfacesN != nil {
		t := *r.interfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaces__n", t, "form", "multi")
		}
	}
	if r.ipVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_version", r.ipVersion, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.maskLength != nil {
		t := *r.maskLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", t, "form", "multi")
		}
	}
	if r.maskLengthGt != nil {
		t := *r.maskLengthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gt", t, "form", "multi")
		}
	}
	if r.maskLengthGte != nil {
		t := *r.maskLengthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", t, "form", "multi")
		}
	}
	if r.maskLengthLt != nil {
		t := *r.maskLengthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lt", t, "form", "multi")
		}
	}
	if r.maskLengthLte != nil {
		t := *r.maskLengthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", t, "form", "multi")
		}
	}
	if r.maskLengthN != nil {
		t := *r.maskLengthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__n", t, "form", "multi")
		}
	}
	if r.namespace != nil {
		t := *r.namespace
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", t, "form", "multi")
		}
	}
	if r.namespaceN != nil {
		t := *r.namespaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", t, "form", "multi")
		}
	}
	if r.natInside != nil {
		t := *r.natInside
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside", t, "form", "multi")
		}
	}
	if r.natInsideIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside__isnull", r.natInsideIsnull, "form", "")
	}
	if r.natInsideN != nil {
		t := *r.natInsideN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "form", "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "form", "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "form", "multi")
		}
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "form", "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__isnull", r.roleIsnull, "form", "")
	}
	if r.roleN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", r.roleN, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", r.statusN, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "form", "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "form", "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "form", "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "form", "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "form", "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "form", "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "form", "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "form", "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "form", "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "form", "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "form", "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "form", "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "form", "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "form", "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "form", "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "form", "multi")
		}
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "form", "multi")
		}
	}
	if r.vmInterfaces != nil {
		t := *r.vmInterfaces
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interfaces", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interfaces", t, "form", "multi")
		}
	}
	if r.vmInterfacesIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interfaces__isnull", r.vmInterfacesIsnull, "form", "")
	}
	if r.vmInterfacesN != nil {
		t := *r.vmInterfacesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interfaces__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vm_interfaces__n", t, "form", "multi")
		}
	}
	if r.vrfs != nil {
		t := *r.vrfs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs", t, "form", "multi")
		}
	}
	if r.vrfsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__isnull", r.vrfsIsnull, "form", "")
	}
	if r.vrfsN != nil {
		t := *r.vrfsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamIpAddressesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamIpAddressesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamIpAddressesNotesCreateExecute(r)
}

/*
IpamIpAddressesNotesCreate Method for IpamIpAddressesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesNotesCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressesNotesCreate(ctx context.Context, id string) ApiIpamIpAddressesNotesCreateRequest {
	return ApiIpamIpAddressesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamIpAddressesNotesCreateExecute(r ApiIpamIpAddressesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamIpAddressesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesNotesListRequest) Limit(limit int32) ApiIpamIpAddressesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesNotesListRequest) Offset(offset int32) ApiIpamIpAddressesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressesNotesListRequest) Depth(depth int32) ApiIpamIpAddressesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesNotesListExecute(r)
}

/*
IpamIpAddressesNotesList Method for IpamIpAddressesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesNotesListRequest
*/
func (a *IpamAPIService) IpamIpAddressesNotesList(ctx context.Context, id string) ApiIpamIpAddressesNotesListRequest {
	return ApiIpamIpAddressesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamIpAddressesNotesListExecute(r ApiIpamIpAddressesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedIPAddressRequest *PatchedIPAddressRequest
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) PatchedIPAddressRequest(patchedIPAddressRequest PatchedIPAddressRequest) ApiIpamIpAddressesPartialUpdateRequest {
	r.patchedIPAddressRequest = &patchedIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesPartialUpdateExecute(r)
}

/*
IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

Partial update a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesPartialUpdate(ctx context.Context, id string) ApiIpamIpAddressesPartialUpdateRequest {
	return ApiIpamIpAddressesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamIpAddressesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamIpAddressesRetrieveRequest) Depth(depth int32) ApiIpamIpAddressesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamIpAddressesRetrieveRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesRetrieveExecute(r)
}

/*
IpamIpAddressesRetrieve Method for IpamIpAddressesRetrieve

Retrieve a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesRetrieveRequest
*/
func (a *IpamAPIService) IpamIpAddressesRetrieve(ctx context.Context, id string) ApiIpamIpAddressesRetrieveRequest {
	return ApiIpamIpAddressesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesRetrieveExecute(r ApiIpamIpAddressesRetrieveRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	iPAddressRequest *IPAddressRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamIpAddressesUpdateRequest) IPAddressRequest(iPAddressRequest IPAddressRequest) ApiIpamIpAddressesUpdateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamIpAddressesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesUpdateExecute(r)
}

/*
IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

Update a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesUpdate(ctx context.Context, id string) ApiIpamIpAddressesUpdateRequest {
	return ApiIpamIpAddressesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamNamespacesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamNamespacesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamNamespacesBulkDestroyExecute(r)
}

/*
IpamNamespacesBulkDestroy Method for IpamNamespacesBulkDestroy

Destroy a list of namespace objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamNamespacesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamNamespacesBulkDestroy(ctx context.Context) ApiIpamNamespacesBulkDestroyRequest {
	return ApiIpamNamespacesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamNamespacesBulkDestroyExecute(r ApiIpamNamespacesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamNamespacesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableNamespaceRequest *[]PatchedBulkWritableNamespaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesBulkPartialUpdateRequest) PatchedBulkWritableNamespaceRequest(patchedBulkWritableNamespaceRequest []PatchedBulkWritableNamespaceRequest) ApiIpamNamespacesBulkPartialUpdateRequest {
	r.patchedBulkWritableNamespaceRequest = &patchedBulkWritableNamespaceRequest
	return r
}

func (r ApiIpamNamespacesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesBulkPartialUpdateRequest) Execute() ([]Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesBulkPartialUpdateExecute(r)
}

/*
IpamNamespacesBulkPartialUpdate Method for IpamNamespacesBulkPartialUpdate

Partial update a list of namespace objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamNamespacesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamNamespacesBulkPartialUpdate(ctx context.Context) ApiIpamNamespacesBulkPartialUpdateRequest {
	return ApiIpamNamespacesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Namespace
func (a *IpamAPIService) IpamNamespacesBulkPartialUpdateExecute(r ApiIpamNamespacesBulkPartialUpdateRequest) ([]Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableNamespaceRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableNamespaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableNamespaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableNamespaceRequest *[]BulkWritableNamespaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesBulkUpdateRequest) BulkWritableNamespaceRequest(bulkWritableNamespaceRequest []BulkWritableNamespaceRequest) ApiIpamNamespacesBulkUpdateRequest {
	r.bulkWritableNamespaceRequest = &bulkWritableNamespaceRequest
	return r
}

func (r ApiIpamNamespacesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesBulkUpdateRequest) Execute() ([]Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesBulkUpdateExecute(r)
}

/*
IpamNamespacesBulkUpdate Method for IpamNamespacesBulkUpdate

Update a list of namespace objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamNamespacesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamNamespacesBulkUpdate(ctx context.Context) ApiIpamNamespacesBulkUpdateRequest {
	return ApiIpamNamespacesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Namespace
func (a *IpamAPIService) IpamNamespacesBulkUpdateExecute(r ApiIpamNamespacesBulkUpdateRequest) ([]Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableNamespaceRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableNamespaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableNamespaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	namespaceRequest *NamespaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesCreateRequest) NamespaceRequest(namespaceRequest NamespaceRequest) ApiIpamNamespacesCreateRequest {
	r.namespaceRequest = &namespaceRequest
	return r
}

func (r ApiIpamNamespacesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesCreateRequest) Execute() (*Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesCreateExecute(r)
}

/*
IpamNamespacesCreate Method for IpamNamespacesCreate

Create one or more namespace objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamNamespacesCreateRequest
*/
func (a *IpamAPIService) IpamNamespacesCreate(ctx context.Context) ApiIpamNamespacesCreateRequest {
	return ApiIpamNamespacesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Namespace
func (a *IpamAPIService) IpamNamespacesCreateExecute(r ApiIpamNamespacesCreateRequest) (*Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.namespaceRequest == nil {
		return localVarReturnValue, nil, reportError("namespaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.namespaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamNamespacesDestroyExecute(r)
}

/*
IpamNamespacesDestroy Method for IpamNamespacesDestroy

Destroy a namespace object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesDestroyRequest
*/
func (a *IpamAPIService) IpamNamespacesDestroy(ctx context.Context, id string) ApiIpamNamespacesDestroyRequest {
	return ApiIpamNamespacesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamNamespacesDestroyExecute(r ApiIpamNamespacesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamNamespacesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *string
	locationIsnull *bool
	locationN *string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	depth *int32
}

func (r ApiIpamNamespacesListRequest) Contacts(contacts []string) ApiIpamNamespacesListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamNamespacesListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamNamespacesListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamNamespacesListRequest) ContactsN(contactsN string) ApiIpamNamespacesListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamNamespacesListRequest) Created(created []time.Time) ApiIpamNamespacesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedGt(createdGt []time.Time) ApiIpamNamespacesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedGte(createdGte []time.Time) ApiIpamNamespacesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedIsnull(createdIsnull bool) ApiIpamNamespacesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedLt(createdLt []time.Time) ApiIpamNamespacesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedLte(createdLte []time.Time) ApiIpamNamespacesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamNamespacesListRequest) CreatedN(createdN []time.Time) ApiIpamNamespacesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamNamespacesListRequest) Description(description []string) ApiIpamNamespacesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionIc(descriptionIc []string) ApiIpamNamespacesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionIe(descriptionIe []string) ApiIpamNamespacesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionIew(descriptionIew []string) ApiIpamNamespacesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionIre(descriptionIre []string) ApiIpamNamespacesListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamNamespacesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionN(descriptionN []string) ApiIpamNamespacesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNic(descriptionNic []string) ApiIpamNamespacesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNie(descriptionNie []string) ApiIpamNamespacesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamNamespacesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNire(descriptionNire []string) ApiIpamNamespacesListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamNamespacesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionNre(descriptionNre []string) ApiIpamNamespacesListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiIpamNamespacesListRequest) DescriptionRe(descriptionRe []string) ApiIpamNamespacesListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiIpamNamespacesListRequest) DynamicGroups(dynamicGroups []string) ApiIpamNamespacesListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamNamespacesListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamNamespacesListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamNamespacesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamNamespacesListRequest) Id(id []string) ApiIpamNamespacesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamNamespacesListRequest) IdIc(idIc []string) ApiIpamNamespacesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamNamespacesListRequest) IdIe(idIe []string) ApiIpamNamespacesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamNamespacesListRequest) IdIew(idIew []string) ApiIpamNamespacesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamNamespacesListRequest) IdIre(idIre []string) ApiIpamNamespacesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamNamespacesListRequest) IdIsw(idIsw []string) ApiIpamNamespacesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamNamespacesListRequest) IdN(idN []string) ApiIpamNamespacesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamNamespacesListRequest) IdNic(idNic []string) ApiIpamNamespacesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamNamespacesListRequest) IdNie(idNie []string) ApiIpamNamespacesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamNamespacesListRequest) IdNiew(idNiew []string) ApiIpamNamespacesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamNamespacesListRequest) IdNire(idNire []string) ApiIpamNamespacesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamNamespacesListRequest) IdNisw(idNisw []string) ApiIpamNamespacesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamNamespacesListRequest) IdNre(idNre []string) ApiIpamNamespacesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamNamespacesListRequest) IdRe(idRe []string) ApiIpamNamespacesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamNamespacesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamNamespacesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamNamespacesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamNamespacesListRequest) Limit(limit int32) ApiIpamNamespacesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamNamespacesListRequest) Location(location string) ApiIpamNamespacesListRequest {
	r.location = &location
	return r
}

func (r ApiIpamNamespacesListRequest) LocationIsnull(locationIsnull bool) ApiIpamNamespacesListRequest {
	r.locationIsnull = &locationIsnull
	return r
}

func (r ApiIpamNamespacesListRequest) LocationN(locationN string) ApiIpamNamespacesListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiIpamNamespacesListRequest) Name(name []string) ApiIpamNamespacesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamNamespacesListRequest) NameIc(nameIc []string) ApiIpamNamespacesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamNamespacesListRequest) NameIe(nameIe []string) ApiIpamNamespacesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamNamespacesListRequest) NameIew(nameIew []string) ApiIpamNamespacesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamNamespacesListRequest) NameIre(nameIre []string) ApiIpamNamespacesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamNamespacesListRequest) NameIsw(nameIsw []string) ApiIpamNamespacesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamNamespacesListRequest) NameN(nameN []string) ApiIpamNamespacesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamNamespacesListRequest) NameNic(nameNic []string) ApiIpamNamespacesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamNamespacesListRequest) NameNie(nameNie []string) ApiIpamNamespacesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamNamespacesListRequest) NameNiew(nameNiew []string) ApiIpamNamespacesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamNamespacesListRequest) NameNire(nameNire []string) ApiIpamNamespacesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamNamespacesListRequest) NameNisw(nameNisw []string) ApiIpamNamespacesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamNamespacesListRequest) NameNre(nameNre []string) ApiIpamNamespacesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamNamespacesListRequest) NameRe(nameRe []string) ApiIpamNamespacesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamNamespacesListRequest) Offset(offset int32) ApiIpamNamespacesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamNamespacesListRequest) Q(q string) ApiIpamNamespacesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamNamespacesListRequest) Sort(sort string) ApiIpamNamespacesListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamNamespacesListRequest) Tags(tags []string) ApiIpamNamespacesListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamNamespacesListRequest) TagsIsnull(tagsIsnull bool) ApiIpamNamespacesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamNamespacesListRequest) TagsN(tagsN []string) ApiIpamNamespacesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamNamespacesListRequest) Teams(teams []string) ApiIpamNamespacesListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamNamespacesListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamNamespacesListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamNamespacesListRequest) TeamsN(teamsN string) ApiIpamNamespacesListRequest {
	r.teamsN = &teamsN
	return r
}

// Serializer Depth
func (r ApiIpamNamespacesListRequest) Depth(depth int32) ApiIpamNamespacesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamNamespacesListRequest) Execute() (*PaginatedNamespaceList, *http.Response, error) {
	return r.ApiService.IpamNamespacesListExecute(r)
}

/*
IpamNamespacesList Method for IpamNamespacesList

Retrieve a list of namespace objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamNamespacesListRequest
*/
func (a *IpamAPIService) IpamNamespacesList(ctx context.Context) ApiIpamNamespacesListRequest {
	return ApiIpamNamespacesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedNamespaceList
func (a *IpamAPIService) IpamNamespacesListExecute(r ApiIpamNamespacesListRequest) (*PaginatedNamespaceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNamespaceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "form", "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "form", "")
	}
	if r.locationIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location__isnull", r.locationIsnull, "form", "")
	}
	if r.locationN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", r.locationN, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamNamespacesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamNamespacesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamNamespacesNotesCreateExecute(r)
}

/*
IpamNamespacesNotesCreate Method for IpamNamespacesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesNotesCreateRequest
*/
func (a *IpamAPIService) IpamNamespacesNotesCreate(ctx context.Context, id string) ApiIpamNamespacesNotesCreateRequest {
	return ApiIpamNamespacesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamNamespacesNotesCreateExecute(r ApiIpamNamespacesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamNamespacesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamNamespacesNotesListRequest) Limit(limit int32) ApiIpamNamespacesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamNamespacesNotesListRequest) Offset(offset int32) ApiIpamNamespacesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamNamespacesNotesListRequest) Depth(depth int32) ApiIpamNamespacesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamNamespacesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamNamespacesNotesListExecute(r)
}

/*
IpamNamespacesNotesList Method for IpamNamespacesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesNotesListRequest
*/
func (a *IpamAPIService) IpamNamespacesNotesList(ctx context.Context, id string) ApiIpamNamespacesNotesListRequest {
	return ApiIpamNamespacesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamNamespacesNotesListExecute(r ApiIpamNamespacesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedNamespaceRequest *PatchedNamespaceRequest
}

func (r ApiIpamNamespacesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesPartialUpdateRequest) PatchedNamespaceRequest(patchedNamespaceRequest PatchedNamespaceRequest) ApiIpamNamespacesPartialUpdateRequest {
	r.patchedNamespaceRequest = &patchedNamespaceRequest
	return r
}

func (r ApiIpamNamespacesPartialUpdateRequest) Execute() (*Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesPartialUpdateExecute(r)
}

/*
IpamNamespacesPartialUpdate Method for IpamNamespacesPartialUpdate

Partial update a namespace object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamNamespacesPartialUpdate(ctx context.Context, id string) ApiIpamNamespacesPartialUpdateRequest {
	return ApiIpamNamespacesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Namespace
func (a *IpamAPIService) IpamNamespacesPartialUpdateExecute(r ApiIpamNamespacesPartialUpdateRequest) (*Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNamespaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamNamespacesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamNamespacesRetrieveRequest) Depth(depth int32) ApiIpamNamespacesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamNamespacesRetrieveRequest) Execute() (*Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesRetrieveExecute(r)
}

/*
IpamNamespacesRetrieve Method for IpamNamespacesRetrieve

Retrieve a namespace object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesRetrieveRequest
*/
func (a *IpamAPIService) IpamNamespacesRetrieve(ctx context.Context, id string) ApiIpamNamespacesRetrieveRequest {
	return ApiIpamNamespacesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Namespace
func (a *IpamAPIService) IpamNamespacesRetrieveExecute(r ApiIpamNamespacesRetrieveRequest) (*Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamNamespacesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	namespaceRequest *NamespaceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamNamespacesUpdateRequest) NamespaceRequest(namespaceRequest NamespaceRequest) ApiIpamNamespacesUpdateRequest {
	r.namespaceRequest = &namespaceRequest
	return r
}

func (r ApiIpamNamespacesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamNamespacesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamNamespacesUpdateRequest) Execute() (*Namespace, *http.Response, error) {
	return r.ApiService.IpamNamespacesUpdateExecute(r)
}

/*
IpamNamespacesUpdate Method for IpamNamespacesUpdate

Update a namespace object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this namespace.
 @return ApiIpamNamespacesUpdateRequest
*/
func (a *IpamAPIService) IpamNamespacesUpdate(ctx context.Context, id string) ApiIpamNamespacesUpdateRequest {
	return ApiIpamNamespacesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Namespace
func (a *IpamAPIService) IpamNamespacesUpdateExecute(r ApiIpamNamespacesUpdateRequest) (*Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamNamespacesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/namespaces/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.namespaceRequest == nil {
		return localVarReturnValue, nil, reportError("namespaceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.namespaceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamPrefixLocationAssignmentsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsBulkDestroyExecute(r)
}

/*
IpamPrefixLocationAssignmentsBulkDestroy Method for IpamPrefixLocationAssignmentsBulkDestroy

Destroy a list of prefix location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixLocationAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkDestroy(ctx context.Context) ApiIpamPrefixLocationAssignmentsBulkDestroyRequest {
	return ApiIpamPrefixLocationAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkDestroyExecute(r ApiIpamPrefixLocationAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritablePrefixLocationAssignmentRequest *[]PatchedBulkWritablePrefixLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest) PatchedBulkWritablePrefixLocationAssignmentRequest(patchedBulkWritablePrefixLocationAssignmentRequest []PatchedBulkWritablePrefixLocationAssignmentRequest) ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest {
	r.patchedBulkWritablePrefixLocationAssignmentRequest = &patchedBulkWritablePrefixLocationAssignmentRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest) Execute() ([]PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamPrefixLocationAssignmentsBulkPartialUpdate Method for IpamPrefixLocationAssignmentsBulkPartialUpdate

Partial update a list of prefix location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest {
	return ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkPartialUpdateExecute(r ApiIpamPrefixLocationAssignmentsBulkPartialUpdateRequest) ([]PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePrefixLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePrefixLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePrefixLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritablePrefixLocationAssignmentRequest *[]BulkWritablePrefixLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsBulkUpdateRequest) BulkWritablePrefixLocationAssignmentRequest(bulkWritablePrefixLocationAssignmentRequest []BulkWritablePrefixLocationAssignmentRequest) ApiIpamPrefixLocationAssignmentsBulkUpdateRequest {
	r.bulkWritablePrefixLocationAssignmentRequest = &bulkWritablePrefixLocationAssignmentRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsBulkUpdateRequest) Execute() ([]PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsBulkUpdateExecute(r)
}

/*
IpamPrefixLocationAssignmentsBulkUpdate Method for IpamPrefixLocationAssignmentsBulkUpdate

Update a list of prefix location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixLocationAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkUpdate(ctx context.Context) ApiIpamPrefixLocationAssignmentsBulkUpdateRequest {
	return ApiIpamPrefixLocationAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsBulkUpdateExecute(r ApiIpamPrefixLocationAssignmentsBulkUpdateRequest) ([]PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePrefixLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePrefixLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePrefixLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	prefixLocationAssignmentRequest *PrefixLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsCreateRequest) PrefixLocationAssignmentRequest(prefixLocationAssignmentRequest PrefixLocationAssignmentRequest) ApiIpamPrefixLocationAssignmentsCreateRequest {
	r.prefixLocationAssignmentRequest = &prefixLocationAssignmentRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsCreateRequest) Execute() (*PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsCreateExecute(r)
}

/*
IpamPrefixLocationAssignmentsCreate Method for IpamPrefixLocationAssignmentsCreate

Create one or more prefix location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixLocationAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsCreate(ctx context.Context) ApiIpamPrefixLocationAssignmentsCreateRequest {
	return ApiIpamPrefixLocationAssignmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsCreateExecute(r ApiIpamPrefixLocationAssignmentsCreateRequest) (*PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("prefixLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsDestroyExecute(r)
}

/*
IpamPrefixLocationAssignmentsDestroy Method for IpamPrefixLocationAssignmentsDestroy

Destroy a prefix location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsDestroy(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsDestroyRequest {
	return ApiIpamPrefixLocationAssignmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixLocationAssignmentsDestroyExecute(r ApiIpamPrefixLocationAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	created *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	offset *int32
	prefix *[]string
	q *string
	sort *string
	depth *int32
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) Created(created []time.Time) ApiIpamPrefixLocationAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamPrefixLocationAssignmentsListRequest) Id(id []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdIc(idIc []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdIe(idIe []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdIew(idIew []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdIre(idIre []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdIsw(idIsw []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdN(idN []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNic(idNic []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNie(idNie []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNiew(idNiew []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNire(idNire []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNisw(idNisw []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdNre(idNre []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) IdRe(idRe []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamPrefixLocationAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixLocationAssignmentsListRequest) Limit(limit int32) ApiIpamPrefixLocationAssignmentsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) Location(location []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.location = &location
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) LocationN(locationN []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.locationN = &locationN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixLocationAssignmentsListRequest) Offset(offset int32) ApiIpamPrefixLocationAssignmentsListRequest {
	r.offset = &offset
	return r
}

// Prefix
func (r ApiIpamPrefixLocationAssignmentsListRequest) Prefix(prefix []string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.prefix = &prefix
	return r
}

// Search
func (r ApiIpamPrefixLocationAssignmentsListRequest) Q(q string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixLocationAssignmentsListRequest) Sort(sort string) ApiIpamPrefixLocationAssignmentsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiIpamPrefixLocationAssignmentsListRequest) Depth(depth int32) ApiIpamPrefixLocationAssignmentsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixLocationAssignmentsListRequest) Execute() (*PaginatedPrefixLocationAssignmentList, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsListExecute(r)
}

/*
IpamPrefixLocationAssignmentsList Method for IpamPrefixLocationAssignmentsList

Retrieve a list of prefix location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixLocationAssignmentsListRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsList(ctx context.Context) ApiIpamPrefixLocationAssignmentsListRequest {
	return ApiIpamPrefixLocationAssignmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPrefixLocationAssignmentList
func (a *IpamAPIService) IpamPrefixLocationAssignmentsListExecute(r ApiIpamPrefixLocationAssignmentsListRequest) (*PaginatedPrefixLocationAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrefixLocationAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamPrefixLocationAssignmentsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsNotesCreateExecute(r)
}

/*
IpamPrefixLocationAssignmentsNotesCreate Method for IpamPrefixLocationAssignmentsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsNotesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsNotesCreate(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsNotesCreateRequest {
	return ApiIpamPrefixLocationAssignmentsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamPrefixLocationAssignmentsNotesCreateExecute(r ApiIpamPrefixLocationAssignmentsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamPrefixLocationAssignmentsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixLocationAssignmentsNotesListRequest) Limit(limit int32) ApiIpamPrefixLocationAssignmentsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixLocationAssignmentsNotesListRequest) Offset(offset int32) ApiIpamPrefixLocationAssignmentsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamPrefixLocationAssignmentsNotesListRequest) Depth(depth int32) ApiIpamPrefixLocationAssignmentsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixLocationAssignmentsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsNotesListExecute(r)
}

/*
IpamPrefixLocationAssignmentsNotesList Method for IpamPrefixLocationAssignmentsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsNotesListRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsNotesList(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsNotesListRequest {
	return ApiIpamPrefixLocationAssignmentsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamPrefixLocationAssignmentsNotesListExecute(r ApiIpamPrefixLocationAssignmentsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedPrefixLocationAssignmentRequest *PatchedPrefixLocationAssignmentRequest
}

func (r ApiIpamPrefixLocationAssignmentsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsPartialUpdateRequest) PatchedPrefixLocationAssignmentRequest(patchedPrefixLocationAssignmentRequest PatchedPrefixLocationAssignmentRequest) ApiIpamPrefixLocationAssignmentsPartialUpdateRequest {
	r.patchedPrefixLocationAssignmentRequest = &patchedPrefixLocationAssignmentRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsPartialUpdateRequest) Execute() (*PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsPartialUpdateExecute(r)
}

/*
IpamPrefixLocationAssignmentsPartialUpdate Method for IpamPrefixLocationAssignmentsPartialUpdate

Partial update a prefix location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsPartialUpdate(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsPartialUpdateRequest {
	return ApiIpamPrefixLocationAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsPartialUpdateExecute(r ApiIpamPrefixLocationAssignmentsPartialUpdateRequest) (*PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPrefixLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamPrefixLocationAssignmentsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamPrefixLocationAssignmentsRetrieveRequest) Depth(depth int32) ApiIpamPrefixLocationAssignmentsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixLocationAssignmentsRetrieveRequest) Execute() (*PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsRetrieveExecute(r)
}

/*
IpamPrefixLocationAssignmentsRetrieve Method for IpamPrefixLocationAssignmentsRetrieve

Retrieve a prefix location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsRetrieve(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsRetrieveRequest {
	return ApiIpamPrefixLocationAssignmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsRetrieveExecute(r ApiIpamPrefixLocationAssignmentsRetrieveRequest) (*PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixLocationAssignmentsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	prefixLocationAssignmentRequest *PrefixLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixLocationAssignmentsUpdateRequest) PrefixLocationAssignmentRequest(prefixLocationAssignmentRequest PrefixLocationAssignmentRequest) ApiIpamPrefixLocationAssignmentsUpdateRequest {
	r.prefixLocationAssignmentRequest = &prefixLocationAssignmentRequest
	return r
}

func (r ApiIpamPrefixLocationAssignmentsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixLocationAssignmentsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixLocationAssignmentsUpdateRequest) Execute() (*PrefixLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamPrefixLocationAssignmentsUpdateExecute(r)
}

/*
IpamPrefixLocationAssignmentsUpdate Method for IpamPrefixLocationAssignmentsUpdate

Update a prefix location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix location assignment.
 @return ApiIpamPrefixLocationAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixLocationAssignmentsUpdate(ctx context.Context, id string) ApiIpamPrefixLocationAssignmentsUpdateRequest {
	return ApiIpamPrefixLocationAssignmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PrefixLocationAssignment
func (a *IpamAPIService) IpamPrefixLocationAssignmentsUpdateExecute(r ApiIpamPrefixLocationAssignmentsUpdateRequest) (*PrefixLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrefixLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixLocationAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefix-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("prefixLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	iPAllocationRequest *[]IPAllocationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	sort *string
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) IPAllocationRequest(iPAllocationRequest []IPAllocationRequest) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.iPAllocationRequest = &iPAllocationRequest
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailableIpsCreateRequest) Limit(limit int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailableIpsCreateRequest) Offset(offset int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesAvailableIpsCreateRequest) Sort(sort string) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Execute() (*PaginatedIPAddressList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsCreateExecute(r)
}

/*
IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

A convenience method for listing and/or allocating available IP addresses within a prefix.

By default, the number of IPs returned will be equivalent to PAGINATE_COUNT.
An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.

This uses a Redis lock to prevent this API from being invoked in parallel, in order to avoid a race condition
if multiple clients tried to simultaneously request allocation from the same parent prefix.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamPrefixesAvailableIpsCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreate(ctx context.Context, id string) ApiIpamPrefixesAvailableIpsCreateRequest {
	return ApiIpamPrefixesAvailableIpsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressList
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) (*PaginatedIPAddressList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAllocationRequest == nil {
		return localVarReturnValue, nil, reportError("iPAllocationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAllocationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	sort *string
	depth *int32
}

func (r ApiIpamPrefixesAvailableIpsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesAvailableIpsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailableIpsListRequest) Limit(limit int32) ApiIpamPrefixesAvailableIpsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailableIpsListRequest) Offset(offset int32) ApiIpamPrefixesAvailableIpsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesAvailableIpsListRequest) Sort(sort string) ApiIpamPrefixesAvailableIpsListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiIpamPrefixesAvailableIpsListRequest) Depth(depth int32) ApiIpamPrefixesAvailableIpsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesAvailableIpsListRequest) Execute() (*PaginatedAvailableIPList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsListExecute(r)
}

/*
IpamPrefixesAvailableIpsList Method for IpamPrefixesAvailableIpsList

A convenience method for listing and/or allocating available IP addresses within a prefix.

By default, the number of IPs returned will be equivalent to PAGINATE_COUNT.
An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.

This uses a Redis lock to prevent this API from being invoked in parallel, in order to avoid a race condition
if multiple clients tried to simultaneously request allocation from the same parent prefix.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamPrefixesAvailableIpsListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsList(ctx context.Context, id string) ApiIpamPrefixesAvailableIpsListRequest {
	return ApiIpamPrefixesAvailableIpsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedAvailableIPList
func (a *IpamAPIService) IpamPrefixesAvailableIpsListExecute(r ApiIpamPrefixesAvailableIpsListRequest) (*PaginatedAvailableIPList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAvailableIPList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	prefixLengthRequest *PrefixLengthRequest
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	sort *string
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) PrefixLengthRequest(prefixLengthRequest PrefixLengthRequest) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.prefixLengthRequest = &prefixLengthRequest
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Limit(limit int32) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Offset(offset int32) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Sort(sort string) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Execute() (*PaginatedPrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesCreateExecute(r)
}

/*
IpamPrefixesAvailablePrefixesCreate Method for IpamPrefixesAvailablePrefixesCreate

A convenience method for listing and/or allocating available child prefixes within a parent.

This uses a Redis lock to prevent this API from being invoked in parallel, in order to avoid a race condition
if multiple clients tried to simultaneously request allocation from the same parent prefix.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id string) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	return ApiIpamPrefixesAvailablePrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedPrefixList
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) (*PaginatedPrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixLengthRequest == nil {
		return localVarReturnValue, nil, reportError("prefixLengthRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixLengthRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	sort *string
	depth *int32
}

func (r ApiIpamPrefixesAvailablePrefixesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Limit(limit int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Offset(offset int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Sort(sort string) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.sort = &sort
	return r
}

// Serializer Depth
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Depth(depth int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesListRequest) Execute() (*PaginatedAvailablePrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesListExecute(r)
}

/*
IpamPrefixesAvailablePrefixesList Method for IpamPrefixesAvailablePrefixesList

A convenience method for listing and/or allocating available child prefixes within a parent.

This uses a Redis lock to prevent this API from being invoked in parallel, in order to avoid a race condition
if multiple clients tried to simultaneously request allocation from the same parent prefix.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesList(ctx context.Context, id string) ApiIpamPrefixesAvailablePrefixesListRequest {
	return ApiIpamPrefixesAvailablePrefixesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedAvailablePrefixList
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesListExecute(r ApiIpamPrefixesAvailablePrefixesListRequest) (*PaginatedAvailablePrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAvailablePrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamPrefixesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamPrefixesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesBulkDestroyExecute(r)
}

/*
IpamPrefixesBulkDestroy Method for IpamPrefixesBulkDestroy

Destroy a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkDestroy(ctx context.Context) ApiIpamPrefixesBulkDestroyRequest {
	return ApiIpamPrefixesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesBulkDestroyExecute(r ApiIpamPrefixesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritablePrefixRequest *[]PatchedBulkWritablePrefixRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) PatchedBulkWritablePrefixRequest(patchedBulkWritablePrefixRequest []PatchedBulkWritablePrefixRequest) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.patchedBulkWritablePrefixRequest = &patchedBulkWritablePrefixRequest
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkPartialUpdateExecute(r)
}

/*
IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

Partial update a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest {
	return ApiIpamPrefixesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritablePrefixRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritablePrefixRequest *[]BulkWritablePrefixRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesBulkUpdateRequest) BulkWritablePrefixRequest(bulkWritablePrefixRequest []BulkWritablePrefixRequest) ApiIpamPrefixesBulkUpdateRequest {
	r.bulkWritablePrefixRequest = &bulkWritablePrefixRequest
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkUpdateExecute(r)
}

/*
IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

Update a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest {
	return ApiIpamPrefixesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritablePrefixRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	writablePrefixRequest *WritablePrefixRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesCreateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesCreateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesCreateExecute(r)
}

/*
IpamPrefixesCreate Method for IpamPrefixesCreate

Create one or more prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest {
	return ApiIpamPrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesDestroyExecute(r)
}

/*
IpamPrefixesDestroy Method for IpamPrefixesDestroy

Destroy a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesDestroy(ctx context.Context, id string) ApiIpamPrefixesDestroyRequest {
	return ApiIpamPrefixesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesDestroyExecute(r ApiIpamPrefixesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	cloudNetworks *[]string
	cloudNetworksIsnull *bool
	cloudNetworksN *[]string
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	contains *[]string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	dateAllocated *[]time.Time
	dateAllocatedGt *[]time.Time
	dateAllocatedGte *[]time.Time
	dateAllocatedIsnull *bool
	dateAllocatedLt *[]time.Time
	dateAllocatedLte *[]time.Time
	dateAllocatedN *[]time.Time
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	hasRir *bool
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	ipVersion *int32
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	locations *[]string
	locationsN *[]string
	namespace *[]string
	namespaceN *[]string
	offset *int32
	parent *[]string
	parentIsnull *bool
	parentN *[]string
	prefix *[]string
	prefixLength *[]int32
	prefixLengthGt *[]int32
	prefixLengthGte *[]int32
	prefixLengthLt *[]int32
	prefixLengthLte *[]int32
	prefixLengthN *[]int32
	presentInVrf *string
	presentInVrfId *string
	q *string
	rir *[]string
	rirIsnull *bool
	rirN *[]string
	role *[]string
	roleIsnull *bool
	roleN *string
	sort *string
	status *[]string
	statusN *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	type_ *[]string
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIre *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNire *[]string
	typeNisw *[]string
	typeNre *[]string
	typeRe *[]string
	vlanId *[]*string
	vlanIdIsnull *bool
	vlanIdN *[]*string
	vlanVid *[]int32
	vlanVidGt *[]int32
	vlanVidGte *[]int32
	vlanVidLt *[]int32
	vlanVidLte *[]int32
	vlanVidN *[]int32
	vrfs *[]string
	vrfsIsnull *bool
	vrfsN *[]string
	within *[]string
	withinInclude *[]string
	depth *int32
}

func (r ApiIpamPrefixesListRequest) CloudNetworks(cloudNetworks []string) ApiIpamPrefixesListRequest {
	r.cloudNetworks = &cloudNetworks
	return r
}

// Cloud Network (name or ID) is null
func (r ApiIpamPrefixesListRequest) CloudNetworksIsnull(cloudNetworksIsnull bool) ApiIpamPrefixesListRequest {
	r.cloudNetworksIsnull = &cloudNetworksIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) CloudNetworksN(cloudNetworksN []string) ApiIpamPrefixesListRequest {
	r.cloudNetworksN = &cloudNetworksN
	return r
}

func (r ApiIpamPrefixesListRequest) Contacts(contacts []string) ApiIpamPrefixesListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamPrefixesListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamPrefixesListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamPrefixesListRequest) ContactsN(contactsN string) ApiIpamPrefixesListRequest {
	r.contactsN = &contactsN
	return r
}

// Prefixes which contain this prefix or IP
func (r ApiIpamPrefixesListRequest) Contains(contains []string) ApiIpamPrefixesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamPrefixesListRequest) Created(created []time.Time) ApiIpamPrefixesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGt(createdGt []time.Time) ApiIpamPrefixesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGte(createdGte []time.Time) ApiIpamPrefixesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedIsnull(createdIsnull bool) ApiIpamPrefixesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLt(createdLt []time.Time) ApiIpamPrefixesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLte(createdLte []time.Time) ApiIpamPrefixesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedN(createdN []time.Time) ApiIpamPrefixesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocated(dateAllocated []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocated = &dateAllocated
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedGt(dateAllocatedGt []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocatedGt = &dateAllocatedGt
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedGte(dateAllocatedGte []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocatedGte = &dateAllocatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedIsnull(dateAllocatedIsnull bool) ApiIpamPrefixesListRequest {
	r.dateAllocatedIsnull = &dateAllocatedIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedLt(dateAllocatedLt []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocatedLt = &dateAllocatedLt
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedLte(dateAllocatedLte []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocatedLte = &dateAllocatedLte
	return r
}

func (r ApiIpamPrefixesListRequest) DateAllocatedN(dateAllocatedN []time.Time) ApiIpamPrefixesListRequest {
	r.dateAllocatedN = &dateAllocatedN
	return r
}

func (r ApiIpamPrefixesListRequest) DynamicGroups(dynamicGroups []string) ApiIpamPrefixesListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamPrefixesListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamPrefixesListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamPrefixesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesListRequest {
	r.format = &format
	return r
}

// Has RIR
func (r ApiIpamPrefixesListRequest) HasRir(hasRir bool) ApiIpamPrefixesListRequest {
	r.hasRir = &hasRir
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamPrefixesListRequest) Id(id []string) ApiIpamPrefixesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixesListRequest) IdIc(idIc []string) ApiIpamPrefixesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamPrefixesListRequest) IdIe(idIe []string) ApiIpamPrefixesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamPrefixesListRequest) IdIew(idIew []string) ApiIpamPrefixesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamPrefixesListRequest) IdIre(idIre []string) ApiIpamPrefixesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamPrefixesListRequest) IdIsw(idIsw []string) ApiIpamPrefixesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamPrefixesListRequest) IdN(idN []string) ApiIpamPrefixesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixesListRequest) IdNic(idNic []string) ApiIpamPrefixesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamPrefixesListRequest) IdNie(idNie []string) ApiIpamPrefixesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamPrefixesListRequest) IdNiew(idNiew []string) ApiIpamPrefixesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamPrefixesListRequest) IdNire(idNire []string) ApiIpamPrefixesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamPrefixesListRequest) IdNisw(idNisw []string) ApiIpamPrefixesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamPrefixesListRequest) IdNre(idNre []string) ApiIpamPrefixesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamPrefixesListRequest) IdRe(idRe []string) ApiIpamPrefixesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamPrefixesListRequest) IpVersion(ipVersion int32) ApiIpamPrefixesListRequest {
	r.ipVersion = &ipVersion
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamPrefixesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesListRequest) Limit(limit int32) ApiIpamPrefixesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamPrefixesListRequest) Location(location []string) ApiIpamPrefixesListRequest {
	r.location = &location
	return r
}

func (r ApiIpamPrefixesListRequest) LocationN(locationN []string) ApiIpamPrefixesListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiIpamPrefixesListRequest) Locations(locations []string) ApiIpamPrefixesListRequest {
	r.locations = &locations
	return r
}

func (r ApiIpamPrefixesListRequest) LocationsN(locationsN []string) ApiIpamPrefixesListRequest {
	r.locationsN = &locationsN
	return r
}

func (r ApiIpamPrefixesListRequest) Namespace(namespace []string) ApiIpamPrefixesListRequest {
	r.namespace = &namespace
	return r
}

func (r ApiIpamPrefixesListRequest) NamespaceN(namespaceN []string) ApiIpamPrefixesListRequest {
	r.namespaceN = &namespaceN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesListRequest) Offset(offset int32) ApiIpamPrefixesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamPrefixesListRequest) Parent(parent []string) ApiIpamPrefixesListRequest {
	r.parent = &parent
	return r
}

func (r ApiIpamPrefixesListRequest) ParentIsnull(parentIsnull bool) ApiIpamPrefixesListRequest {
	r.parentIsnull = &parentIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) ParentN(parentN []string) ApiIpamPrefixesListRequest {
	r.parentN = &parentN
	return r
}

// Prefix
func (r ApiIpamPrefixesListRequest) Prefix(prefix []string) ApiIpamPrefixesListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLength(prefixLength []int32) ApiIpamPrefixesListRequest {
	r.prefixLength = &prefixLength
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLengthGt(prefixLengthGt []int32) ApiIpamPrefixesListRequest {
	r.prefixLengthGt = &prefixLengthGt
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLengthGte(prefixLengthGte []int32) ApiIpamPrefixesListRequest {
	r.prefixLengthGte = &prefixLengthGte
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLengthLt(prefixLengthLt []int32) ApiIpamPrefixesListRequest {
	r.prefixLengthLt = &prefixLengthLt
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLengthLte(prefixLengthLte []int32) ApiIpamPrefixesListRequest {
	r.prefixLengthLte = &prefixLengthLte
	return r
}

func (r ApiIpamPrefixesListRequest) PrefixLengthN(prefixLengthN []int32) ApiIpamPrefixesListRequest {
	r.prefixLengthN = &prefixLengthN
	return r
}

// Present in VRF (RD)
func (r ApiIpamPrefixesListRequest) PresentInVrf(presentInVrf string) ApiIpamPrefixesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// Present in VRF
func (r ApiIpamPrefixesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamPrefixesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamPrefixesListRequest) Q(q string) ApiIpamPrefixesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamPrefixesListRequest) Rir(rir []string) ApiIpamPrefixesListRequest {
	r.rir = &rir
	return r
}

// RIR (name or ID) is null
func (r ApiIpamPrefixesListRequest) RirIsnull(rirIsnull bool) ApiIpamPrefixesListRequest {
	r.rirIsnull = &rirIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) RirN(rirN []string) ApiIpamPrefixesListRequest {
	r.rirN = &rirN
	return r
}

func (r ApiIpamPrefixesListRequest) Role(role []string) ApiIpamPrefixesListRequest {
	r.role = &role
	return r
}

// Role (name or ID) is null
func (r ApiIpamPrefixesListRequest) RoleIsnull(roleIsnull bool) ApiIpamPrefixesListRequest {
	r.roleIsnull = &roleIsnull
	return r
}

// Exclude Role (name or ID)
func (r ApiIpamPrefixesListRequest) RoleN(roleN string) ApiIpamPrefixesListRequest {
	r.roleN = &roleN
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesListRequest) Sort(sort string) ApiIpamPrefixesListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamPrefixesListRequest) Status(status []string) ApiIpamPrefixesListRequest {
	r.status = &status
	return r
}

// Exclude Status (name or ID)
func (r ApiIpamPrefixesListRequest) StatusN(statusN string) ApiIpamPrefixesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamPrefixesListRequest) Tags(tags []string) ApiIpamPrefixesListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamPrefixesListRequest) TagsIsnull(tagsIsnull bool) ApiIpamPrefixesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) TagsN(tagsN []string) ApiIpamPrefixesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamPrefixesListRequest) Teams(teams []string) ApiIpamPrefixesListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamPrefixesListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamPrefixesListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamPrefixesListRequest) TeamsN(teamsN string) ApiIpamPrefixesListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamPrefixesListRequest) Tenant(tenant []string) ApiIpamPrefixesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (name or ID) is null
func (r ApiIpamPrefixesListRequest) TenantIsnull(tenantIsnull bool) ApiIpamPrefixesListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) TenantN(tenantN []string) ApiIpamPrefixesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroup(tenantGroup []string) ApiIpamPrefixesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (name or ID) is null
func (r ApiIpamPrefixesListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiIpamPrefixesListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamPrefixesListRequest) TenantId(tenantId []*string) ApiIpamPrefixesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead) is null
func (r ApiIpamPrefixesListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiIpamPrefixesListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Exclude Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamPrefixesListRequest) TenantIdN(tenantIdN []*string) ApiIpamPrefixesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamPrefixesListRequest) Type_(type_ []string) ApiIpamPrefixesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiIpamPrefixesListRequest) TypeIc(typeIc []string) ApiIpamPrefixesListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiIpamPrefixesListRequest) TypeIe(typeIe []string) ApiIpamPrefixesListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiIpamPrefixesListRequest) TypeIew(typeIew []string) ApiIpamPrefixesListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiIpamPrefixesListRequest) TypeIre(typeIre []string) ApiIpamPrefixesListRequest {
	r.typeIre = &typeIre
	return r
}

func (r ApiIpamPrefixesListRequest) TypeIsw(typeIsw []string) ApiIpamPrefixesListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiIpamPrefixesListRequest) TypeN(typeN []string) ApiIpamPrefixesListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNic(typeNic []string) ApiIpamPrefixesListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNie(typeNie []string) ApiIpamPrefixesListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNiew(typeNiew []string) ApiIpamPrefixesListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNire(typeNire []string) ApiIpamPrefixesListRequest {
	r.typeNire = &typeNire
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNisw(typeNisw []string) ApiIpamPrefixesListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiIpamPrefixesListRequest) TypeNre(typeNre []string) ApiIpamPrefixesListRequest {
	r.typeNre = &typeNre
	return r
}

func (r ApiIpamPrefixesListRequest) TypeRe(typeRe []string) ApiIpamPrefixesListRequest {
	r.typeRe = &typeRe
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanId(vlanId []*string) ApiIpamPrefixesListRequest {
	r.vlanId = &vlanId
	return r
}

// VLAN (ID) is null
func (r ApiIpamPrefixesListRequest) VlanIdIsnull(vlanIdIsnull bool) ApiIpamPrefixesListRequest {
	r.vlanIdIsnull = &vlanIdIsnull
	return r
}

// Exclude VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanIdN(vlanIdN []*string) ApiIpamPrefixesListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

// VLAN number (1-4095)
func (r ApiIpamPrefixesListRequest) VlanVid(vlanVid []int32) ApiIpamPrefixesListRequest {
	r.vlanVid = &vlanVid
	return r
}

// VLAN number (1-4095) is greater than
func (r ApiIpamPrefixesListRequest) VlanVidGt(vlanVidGt []int32) ApiIpamPrefixesListRequest {
	r.vlanVidGt = &vlanVidGt
	return r
}

// VLAN number (1-4095) is greater than or equal to
func (r ApiIpamPrefixesListRequest) VlanVidGte(vlanVidGte []int32) ApiIpamPrefixesListRequest {
	r.vlanVidGte = &vlanVidGte
	return r
}

// VLAN number (1-4095) is less than
func (r ApiIpamPrefixesListRequest) VlanVidLt(vlanVidLt []int32) ApiIpamPrefixesListRequest {
	r.vlanVidLt = &vlanVidLt
	return r
}

// VLAN number (1-4095) is less than or equal to
func (r ApiIpamPrefixesListRequest) VlanVidLte(vlanVidLte []int32) ApiIpamPrefixesListRequest {
	r.vlanVidLte = &vlanVidLte
	return r
}

// Exclude VLAN number (1-4095)
func (r ApiIpamPrefixesListRequest) VlanVidN(vlanVidN []int32) ApiIpamPrefixesListRequest {
	r.vlanVidN = &vlanVidN
	return r
}

func (r ApiIpamPrefixesListRequest) Vrfs(vrfs []string) ApiIpamPrefixesListRequest {
	r.vrfs = &vrfs
	return r
}

// Assigned VRF (ID or RD) is null
func (r ApiIpamPrefixesListRequest) VrfsIsnull(vrfsIsnull bool) ApiIpamPrefixesListRequest {
	r.vrfsIsnull = &vrfsIsnull
	return r
}

func (r ApiIpamPrefixesListRequest) VrfsN(vrfsN []string) ApiIpamPrefixesListRequest {
	r.vrfsN = &vrfsN
	return r
}

// Within prefix
func (r ApiIpamPrefixesListRequest) Within(within []string) ApiIpamPrefixesListRequest {
	r.within = &within
	return r
}

// Within and including prefix
func (r ApiIpamPrefixesListRequest) WithinInclude(withinInclude []string) ApiIpamPrefixesListRequest {
	r.withinInclude = &withinInclude
	return r
}

// Serializer Depth
func (r ApiIpamPrefixesListRequest) Depth(depth int32) ApiIpamPrefixesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesListRequest) Execute() (*PaginatedPrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesListExecute(r)
}

/*
IpamPrefixesList Method for IpamPrefixesList

Retrieve a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest {
	return ApiIpamPrefixesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPrefixList
func (a *IpamAPIService) IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*PaginatedPrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudNetworks != nil {
		t := *r.cloudNetworks
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_networks", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_networks", t, "form", "multi")
		}
	}
	if r.cloudNetworksIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_networks__isnull", r.cloudNetworksIsnull, "form", "")
	}
	if r.cloudNetworksN != nil {
		t := *r.cloudNetworksN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_networks__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cloud_networks__n", t, "form", "multi")
		}
	}
	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.contains != nil {
		t := *r.contains
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contains", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contains", t, "form", "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.dateAllocated != nil {
		t := *r.dateAllocated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated", t, "form", "multi")
		}
	}
	if r.dateAllocatedGt != nil {
		t := *r.dateAllocatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__gt", t, "form", "multi")
		}
	}
	if r.dateAllocatedGte != nil {
		t := *r.dateAllocatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__gte", t, "form", "multi")
		}
	}
	if r.dateAllocatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__isnull", r.dateAllocatedIsnull, "form", "")
	}
	if r.dateAllocatedLt != nil {
		t := *r.dateAllocatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__lt", t, "form", "multi")
		}
	}
	if r.dateAllocatedLte != nil {
		t := *r.dateAllocatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__lte", t, "form", "multi")
		}
	}
	if r.dateAllocatedN != nil {
		t := *r.dateAllocatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_allocated__n", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.hasRir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_rir", r.hasRir, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.ipVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_version", r.ipVersion, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations", t, "form", "multi")
		}
	}
	if r.locationsN != nil {
		t := *r.locationsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations__n", t, "form", "multi")
		}
	}
	if r.namespace != nil {
		t := *r.namespace
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", t, "form", "multi")
		}
	}
	if r.namespaceN != nil {
		t := *r.namespaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "form", "multi")
		}
	}
	if r.parentIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent__isnull", r.parentIsnull, "form", "")
	}
	if r.parentN != nil {
		t := *r.parentN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent__n", t, "form", "multi")
		}
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.prefixLength != nil {
		t := *r.prefixLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length", t, "form", "multi")
		}
	}
	if r.prefixLengthGt != nil {
		t := *r.prefixLengthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__gt", t, "form", "multi")
		}
	}
	if r.prefixLengthGte != nil {
		t := *r.prefixLengthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__gte", t, "form", "multi")
		}
	}
	if r.prefixLengthLt != nil {
		t := *r.prefixLengthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__lt", t, "form", "multi")
		}
	}
	if r.prefixLengthLte != nil {
		t := *r.prefixLengthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__lte", t, "form", "multi")
		}
	}
	if r.prefixLengthN != nil {
		t := *r.prefixLengthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix_length__n", t, "form", "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "form", "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "form", "multi")
		}
	}
	if r.rirIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rir__isnull", r.rirIsnull, "form", "")
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "form", "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__isnull", r.roleIsnull, "form", "")
	}
	if r.roleN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", r.roleN, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", r.statusN, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "form", "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "form", "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "form", "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "form", "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "form", "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "form", "multi")
		}
	}
	if r.typeIre != nil {
		t := *r.typeIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ire", t, "form", "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "form", "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "form", "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "form", "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "form", "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "form", "multi")
		}
	}
	if r.typeNire != nil {
		t := *r.typeNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nire", t, "form", "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "form", "multi")
		}
	}
	if r.typeNre != nil {
		t := *r.typeNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nre", t, "form", "multi")
		}
	}
	if r.typeRe != nil {
		t := *r.typeRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__re", t, "form", "multi")
		}
	}
	if r.vlanId != nil {
		t := *r.vlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", t, "form", "multi")
		}
	}
	if r.vlanIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__isnull", r.vlanIdIsnull, "form", "")
	}
	if r.vlanIdN != nil {
		t := *r.vlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", t, "form", "multi")
		}
	}
	if r.vlanVid != nil {
		t := *r.vlanVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid", t, "form", "multi")
		}
	}
	if r.vlanVidGt != nil {
		t := *r.vlanVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gt", t, "form", "multi")
		}
	}
	if r.vlanVidGte != nil {
		t := *r.vlanVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gte", t, "form", "multi")
		}
	}
	if r.vlanVidLt != nil {
		t := *r.vlanVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lt", t, "form", "multi")
		}
	}
	if r.vlanVidLte != nil {
		t := *r.vlanVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lte", t, "form", "multi")
		}
	}
	if r.vlanVidN != nil {
		t := *r.vlanVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__n", t, "form", "multi")
		}
	}
	if r.vrfs != nil {
		t := *r.vrfs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs", t, "form", "multi")
		}
	}
	if r.vrfsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__isnull", r.vrfsIsnull, "form", "")
	}
	if r.vrfsN != nil {
		t := *r.vrfsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfs__n", t, "form", "multi")
		}
	}
	if r.within != nil {
		t := *r.within
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "within", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "within", t, "form", "multi")
		}
	}
	if r.withinInclude != nil {
		t := *r.withinInclude
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "within_include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "within_include", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamPrefixesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamPrefixesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamPrefixesNotesCreateExecute(r)
}

/*
IpamPrefixesNotesCreate Method for IpamPrefixesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesNotesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesNotesCreate(ctx context.Context, id string) ApiIpamPrefixesNotesCreateRequest {
	return ApiIpamPrefixesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamPrefixesNotesCreateExecute(r ApiIpamPrefixesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamPrefixesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesNotesListRequest) Limit(limit int32) ApiIpamPrefixesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesNotesListRequest) Offset(offset int32) ApiIpamPrefixesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamPrefixesNotesListRequest) Depth(depth int32) ApiIpamPrefixesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamPrefixesNotesListExecute(r)
}

/*
IpamPrefixesNotesList Method for IpamPrefixesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesNotesListRequest
*/
func (a *IpamAPIService) IpamPrefixesNotesList(ctx context.Context, id string) ApiIpamPrefixesNotesListRequest {
	return ApiIpamPrefixesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamPrefixesNotesListExecute(r ApiIpamPrefixesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritablePrefixRequest *PatchedWritablePrefixRequest
}

func (r ApiIpamPrefixesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) PatchedWritablePrefixRequest(patchedWritablePrefixRequest PatchedWritablePrefixRequest) ApiIpamPrefixesPartialUpdateRequest {
	r.patchedWritablePrefixRequest = &patchedWritablePrefixRequest
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesPartialUpdateExecute(r)
}

/*
IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

Partial update a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesPartialUpdate(ctx context.Context, id string) ApiIpamPrefixesPartialUpdateRequest {
	return ApiIpamPrefixesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamPrefixesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamPrefixesRetrieveRequest) Depth(depth int32) ApiIpamPrefixesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesRetrieveRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesRetrieveExecute(r)
}

/*
IpamPrefixesRetrieve Method for IpamPrefixesRetrieve

Retrieve a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesRetrieveRequest
*/
func (a *IpamAPIService) IpamPrefixesRetrieve(ctx context.Context, id string) ApiIpamPrefixesRetrieveRequest {
	return ApiIpamPrefixesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesRetrieveExecute(r ApiIpamPrefixesRetrieveRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	writablePrefixRequest *WritablePrefixRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamPrefixesUpdateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesUpdateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamPrefixesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesUpdateExecute(r)
}

/*
IpamPrefixesUpdate Method for IpamPrefixesUpdate

Update a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesUpdate(ctx context.Context, id string) ApiIpamPrefixesUpdateRequest {
	return ApiIpamPrefixesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamRirsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamRirsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsBulkDestroyExecute(r)
}

/*
IpamRirsBulkDestroy Method for IpamRirsBulkDestroy

Destroy a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRirsBulkDestroy(ctx context.Context) ApiIpamRirsBulkDestroyRequest {
	return ApiIpamRirsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsBulkDestroyExecute(r ApiIpamRirsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableRIRRequest *[]PatchedBulkWritableRIRRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsBulkPartialUpdateRequest) PatchedBulkWritableRIRRequest(patchedBulkWritableRIRRequest []PatchedBulkWritableRIRRequest) ApiIpamRirsBulkPartialUpdateRequest {
	r.patchedBulkWritableRIRRequest = &patchedBulkWritableRIRRequest
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkPartialUpdateExecute(r)
}

/*
IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

Partial update a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest {
	return ApiIpamRirsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RIR
func (a *IpamAPIService) IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRIRRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRIRRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableRIRRequest *[]BulkWritableRIRRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsBulkUpdateRequest) BulkWritableRIRRequest(bulkWritableRIRRequest []BulkWritableRIRRequest) ApiIpamRirsBulkUpdateRequest {
	r.bulkWritableRIRRequest = &bulkWritableRIRRequest
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkUpdateExecute(r)
}

/*
IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

Update a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest {
	return ApiIpamRirsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RIR
func (a *IpamAPIService) IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRIRRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRIRRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	rIRRequest *RIRRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsCreateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsCreateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsCreateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsCreateExecute(r)
}

/*
IpamRirsCreate Method for IpamRirsCreate

Create one or more RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsCreateRequest
*/
func (a *IpamAPIService) IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest {
	return ApiIpamRirsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsDestroyExecute(r)
}

/*
IpamRirsDestroy Method for IpamRirsDestroy

Destroy a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsDestroyRequest
*/
func (a *IpamAPIService) IpamRirsDestroy(ctx context.Context, id string) ApiIpamRirsDestroyRequest {
	return ApiIpamRirsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsDestroyExecute(r ApiIpamRirsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	isPrivate *bool
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	depth *int32
}

func (r ApiIpamRirsListRequest) Contacts(contacts []string) ApiIpamRirsListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamRirsListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamRirsListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamRirsListRequest) ContactsN(contactsN string) ApiIpamRirsListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamRirsListRequest) Created(created []time.Time) ApiIpamRirsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRirsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRirsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRirsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRirsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRirsListRequest) CreatedIsnull(createdIsnull bool) ApiIpamRirsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamRirsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRirsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRirsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRirsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRirsListRequest) CreatedN(createdN []time.Time) ApiIpamRirsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRirsListRequest) Description(description []string) ApiIpamRirsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRirsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRirsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRirsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIre(descriptionIre []string) ApiIpamRirsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRirsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionN(descriptionN []string) ApiIpamRirsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRirsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRirsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRirsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNire(descriptionNire []string) ApiIpamRirsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRirsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNre(descriptionNre []string) ApiIpamRirsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiIpamRirsListRequest) DescriptionRe(descriptionRe []string) ApiIpamRirsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiIpamRirsListRequest) DynamicGroups(dynamicGroups []string) ApiIpamRirsListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamRirsListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamRirsListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamRirsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamRirsListRequest) Id(id []string) ApiIpamRirsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRirsListRequest) IdIc(idIc []string) ApiIpamRirsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamRirsListRequest) IdIe(idIe []string) ApiIpamRirsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamRirsListRequest) IdIew(idIew []string) ApiIpamRirsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamRirsListRequest) IdIre(idIre []string) ApiIpamRirsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamRirsListRequest) IdIsw(idIsw []string) ApiIpamRirsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamRirsListRequest) IdN(idN []string) ApiIpamRirsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRirsListRequest) IdNic(idNic []string) ApiIpamRirsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamRirsListRequest) IdNie(idNie []string) ApiIpamRirsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamRirsListRequest) IdNiew(idNiew []string) ApiIpamRirsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamRirsListRequest) IdNire(idNire []string) ApiIpamRirsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamRirsListRequest) IdNisw(idNisw []string) ApiIpamRirsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamRirsListRequest) IdNre(idNre []string) ApiIpamRirsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamRirsListRequest) IdRe(idRe []string) ApiIpamRirsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamRirsListRequest) IsPrivate(isPrivate bool) ApiIpamRirsListRequest {
	r.isPrivate = &isPrivate
	return r
}

func (r ApiIpamRirsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRirsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamRirsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsListRequest) Limit(limit int32) ApiIpamRirsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRirsListRequest) Name(name []string) ApiIpamRirsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRirsListRequest) NameIc(nameIc []string) ApiIpamRirsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRirsListRequest) NameIe(nameIe []string) ApiIpamRirsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRirsListRequest) NameIew(nameIew []string) ApiIpamRirsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRirsListRequest) NameIre(nameIre []string) ApiIpamRirsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamRirsListRequest) NameIsw(nameIsw []string) ApiIpamRirsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRirsListRequest) NameN(nameN []string) ApiIpamRirsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRirsListRequest) NameNic(nameNic []string) ApiIpamRirsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRirsListRequest) NameNie(nameNie []string) ApiIpamRirsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRirsListRequest) NameNiew(nameNiew []string) ApiIpamRirsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRirsListRequest) NameNire(nameNire []string) ApiIpamRirsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamRirsListRequest) NameNisw(nameNisw []string) ApiIpamRirsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRirsListRequest) NameNre(nameNre []string) ApiIpamRirsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamRirsListRequest) NameRe(nameRe []string) ApiIpamRirsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsListRequest) Offset(offset int32) ApiIpamRirsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamRirsListRequest) Q(q string) ApiIpamRirsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRirsListRequest) Sort(sort string) ApiIpamRirsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamRirsListRequest) Teams(teams []string) ApiIpamRirsListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamRirsListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamRirsListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamRirsListRequest) TeamsN(teamsN string) ApiIpamRirsListRequest {
	r.teamsN = &teamsN
	return r
}

// Serializer Depth
func (r ApiIpamRirsListRequest) Depth(depth int32) ApiIpamRirsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRirsListRequest) Execute() (*PaginatedRIRList, *http.Response, error) {
	return r.ApiService.IpamRirsListExecute(r)
}

/*
IpamRirsList Method for IpamRirsList

Retrieve a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsListRequest
*/
func (a *IpamAPIService) IpamRirsList(ctx context.Context) ApiIpamRirsListRequest {
	return ApiIpamRirsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRIRList
func (a *IpamAPIService) IpamRirsListExecute(r ApiIpamRirsListRequest) (*PaginatedRIRList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRIRList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "form", "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.isPrivate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_private", r.isPrivate, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamRirsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamRirsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamRirsNotesCreateExecute(r)
}

/*
IpamRirsNotesCreate Method for IpamRirsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsNotesCreateRequest
*/
func (a *IpamAPIService) IpamRirsNotesCreate(ctx context.Context, id string) ApiIpamRirsNotesCreateRequest {
	return ApiIpamRirsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamRirsNotesCreateExecute(r ApiIpamRirsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamRirsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsNotesListRequest) Limit(limit int32) ApiIpamRirsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsNotesListRequest) Offset(offset int32) ApiIpamRirsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamRirsNotesListRequest) Depth(depth int32) ApiIpamRirsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRirsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamRirsNotesListExecute(r)
}

/*
IpamRirsNotesList Method for IpamRirsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsNotesListRequest
*/
func (a *IpamAPIService) IpamRirsNotesList(ctx context.Context, id string) ApiIpamRirsNotesListRequest {
	return ApiIpamRirsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamRirsNotesListExecute(r ApiIpamRirsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedRIRRequest *PatchedRIRRequest
}

func (r ApiIpamRirsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) PatchedRIRRequest(patchedRIRRequest PatchedRIRRequest) ApiIpamRirsPartialUpdateRequest {
	r.patchedRIRRequest = &patchedRIRRequest
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsPartialUpdateExecute(r)
}

/*
IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

Partial update a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsPartialUpdate(ctx context.Context, id string) ApiIpamRirsPartialUpdateRequest {
	return ApiIpamRirsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamRirsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamRirsRetrieveRequest) Depth(depth int32) ApiIpamRirsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRirsRetrieveRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsRetrieveExecute(r)
}

/*
IpamRirsRetrieve Method for IpamRirsRetrieve

Retrieve a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsRetrieveRequest
*/
func (a *IpamAPIService) IpamRirsRetrieve(ctx context.Context, id string) ApiIpamRirsRetrieveRequest {
	return ApiIpamRirsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsRetrieveExecute(r ApiIpamRirsRetrieveRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	rIRRequest *RIRRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRirsUpdateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRirsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRirsUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsUpdateExecute(r)
}

/*
IpamRirsUpdate Method for IpamRirsUpdate

Update a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsUpdateRequest
*/
func (a *IpamAPIService) IpamRirsUpdate(ctx context.Context, id string) ApiIpamRirsUpdateRequest {
	return ApiIpamRirsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamRouteTargetsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkDestroyExecute(r)
}

/*
IpamRouteTargetsBulkDestroy Method for IpamRouteTargetsBulkDestroy

Destroy a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkDestroy(ctx context.Context) ApiIpamRouteTargetsBulkDestroyRequest {
	return ApiIpamRouteTargetsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsBulkDestroyExecute(r ApiIpamRouteTargetsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableRouteTargetRequest *[]PatchedBulkWritableRouteTargetRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) PatchedBulkWritableRouteTargetRequest(patchedBulkWritableRouteTargetRequest []PatchedBulkWritableRouteTargetRequest) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.patchedBulkWritableRouteTargetRequest = &patchedBulkWritableRouteTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkPartialUpdateExecute(r)
}

/*
IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

Partial update a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	return ApiIpamRouteTargetsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableRouteTargetRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableRouteTargetRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableRouteTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableRouteTargetRequest *[]BulkWritableRouteTargetRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) BulkWritableRouteTargetRequest(bulkWritableRouteTargetRequest []BulkWritableRouteTargetRequest) ApiIpamRouteTargetsBulkUpdateRequest {
	r.bulkWritableRouteTargetRequest = &bulkWritableRouteTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkUpdateExecute(r)
}

/*
IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

Update a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest {
	return ApiIpamRouteTargetsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableRouteTargetRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableRouteTargetRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableRouteTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	routeTargetRequest *RouteTargetRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsCreateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsCreateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsCreateExecute(r)
}

/*
IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

Create one or more route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsCreateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest {
	return ApiIpamRouteTargetsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsDestroyExecute(r)
}

/*
IpamRouteTargetsDestroy Method for IpamRouteTargetsDestroy

Destroy a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsDestroy(ctx context.Context, id string) ApiIpamRouteTargetsDestroyRequest {
	return ApiIpamRouteTargetsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsDestroyExecute(r ApiIpamRouteTargetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	dynamicGroups *[]string
	dynamicGroupsN *string
	exportingVrfs *[]string
	exportingVrfsIsnull *bool
	exportingVrfsN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	importingVrfs *[]string
	importingVrfsIsnull *bool
	importingVrfsN *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	depth *int32
}

func (r ApiIpamRouteTargetsListRequest) Contacts(contacts []string) ApiIpamRouteTargetsListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamRouteTargetsListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamRouteTargetsListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamRouteTargetsListRequest) ContactsN(contactsN string) ApiIpamRouteTargetsListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Created(created []time.Time) ApiIpamRouteTargetsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedIsnull(createdIsnull bool) ApiIpamRouteTargetsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedN(createdN []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) DynamicGroups(dynamicGroups []string) ApiIpamRouteTargetsListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamRouteTargetsListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamRouteTargetsListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrfs(exportingVrfs []string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfs = &exportingVrfs
	return r
}

// Export VRF(s) (ID or RD) is null
func (r ApiIpamRouteTargetsListRequest) ExportingVrfsIsnull(exportingVrfsIsnull bool) ApiIpamRouteTargetsListRequest {
	r.exportingVrfsIsnull = &exportingVrfsIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) ExportingVrfsN(exportingVrfsN []string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfsN = &exportingVrfsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamRouteTargetsListRequest) Id(id []string) ApiIpamRouteTargetsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIc(idIc []string) ApiIpamRouteTargetsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIe(idIe []string) ApiIpamRouteTargetsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIew(idIew []string) ApiIpamRouteTargetsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIre(idIre []string) ApiIpamRouteTargetsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIsw(idIsw []string) ApiIpamRouteTargetsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdN(idN []string) ApiIpamRouteTargetsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNic(idNic []string) ApiIpamRouteTargetsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNie(idNie []string) ApiIpamRouteTargetsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNiew(idNiew []string) ApiIpamRouteTargetsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNire(idNire []string) ApiIpamRouteTargetsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNisw(idNisw []string) ApiIpamRouteTargetsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNre(idNre []string) ApiIpamRouteTargetsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdRe(idRe []string) ApiIpamRouteTargetsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrfs(importingVrfs []string) ApiIpamRouteTargetsListRequest {
	r.importingVrfs = &importingVrfs
	return r
}

// Import VRF(s) (ID or RD) is null
func (r ApiIpamRouteTargetsListRequest) ImportingVrfsIsnull(importingVrfsIsnull bool) ApiIpamRouteTargetsListRequest {
	r.importingVrfsIsnull = &importingVrfsIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) ImportingVrfsN(importingVrfsN []string) ApiIpamRouteTargetsListRequest {
	r.importingVrfsN = &importingVrfsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsListRequest) Limit(limit int32) ApiIpamRouteTargetsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRouteTargetsListRequest) Name(name []string) ApiIpamRouteTargetsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIc(nameIc []string) ApiIpamRouteTargetsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIe(nameIe []string) ApiIpamRouteTargetsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIew(nameIew []string) ApiIpamRouteTargetsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIre(nameIre []string) ApiIpamRouteTargetsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIsw(nameIsw []string) ApiIpamRouteTargetsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameN(nameN []string) ApiIpamRouteTargetsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNic(nameNic []string) ApiIpamRouteTargetsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNie(nameNie []string) ApiIpamRouteTargetsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNiew(nameNiew []string) ApiIpamRouteTargetsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNire(nameNire []string) ApiIpamRouteTargetsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNisw(nameNisw []string) ApiIpamRouteTargetsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNre(nameNre []string) ApiIpamRouteTargetsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameRe(nameRe []string) ApiIpamRouteTargetsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsListRequest) Offset(offset int32) ApiIpamRouteTargetsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamRouteTargetsListRequest) Q(q string) ApiIpamRouteTargetsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRouteTargetsListRequest) Sort(sort string) ApiIpamRouteTargetsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tags(tags []string) ApiIpamRouteTargetsListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagsIsnull(tagsIsnull bool) ApiIpamRouteTargetsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagsN(tagsN []string) ApiIpamRouteTargetsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Teams(teams []string) ApiIpamRouteTargetsListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamRouteTargetsListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamRouteTargetsListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamRouteTargetsListRequest) TeamsN(teamsN string) ApiIpamRouteTargetsListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tenant(tenant []string) ApiIpamRouteTargetsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (name or ID) is null
func (r ApiIpamRouteTargetsListRequest) TenantIsnull(tenantIsnull bool) ApiIpamRouteTargetsListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantN(tenantN []string) ApiIpamRouteTargetsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroup(tenantGroup []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (name or ID) is null
func (r ApiIpamRouteTargetsListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiIpamRouteTargetsListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamRouteTargetsListRequest) TenantId(tenantId []*string) ApiIpamRouteTargetsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead) is null
func (r ApiIpamRouteTargetsListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiIpamRouteTargetsListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Exclude Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamRouteTargetsListRequest) TenantIdN(tenantIdN []*string) ApiIpamRouteTargetsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Serializer Depth
func (r ApiIpamRouteTargetsListRequest) Depth(depth int32) ApiIpamRouteTargetsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRouteTargetsListRequest) Execute() (*PaginatedRouteTargetList, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsListExecute(r)
}

/*
IpamRouteTargetsList Method for IpamRouteTargetsList

Retrieve a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsListRequest
*/
func (a *IpamAPIService) IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest {
	return ApiIpamRouteTargetsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRouteTargetList
func (a *IpamAPIService) IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*PaginatedRouteTargetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRouteTargetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.exportingVrfs != nil {
		t := *r.exportingVrfs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrfs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrfs", t, "form", "multi")
		}
	}
	if r.exportingVrfsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrfs__isnull", r.exportingVrfsIsnull, "form", "")
	}
	if r.exportingVrfsN != nil {
		t := *r.exportingVrfsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrfs__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrfs__n", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.importingVrfs != nil {
		t := *r.importingVrfs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrfs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrfs", t, "form", "multi")
		}
	}
	if r.importingVrfsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrfs__isnull", r.importingVrfsIsnull, "form", "")
	}
	if r.importingVrfsN != nil {
		t := *r.importingVrfsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrfs__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrfs__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "form", "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "form", "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "form", "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamRouteTargetsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamRouteTargetsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsNotesCreateExecute(r)
}

/*
IpamRouteTargetsNotesCreate Method for IpamRouteTargetsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsNotesCreateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsNotesCreate(ctx context.Context, id string) ApiIpamRouteTargetsNotesCreateRequest {
	return ApiIpamRouteTargetsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamRouteTargetsNotesCreateExecute(r ApiIpamRouteTargetsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamRouteTargetsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsNotesListRequest) Limit(limit int32) ApiIpamRouteTargetsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsNotesListRequest) Offset(offset int32) ApiIpamRouteTargetsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamRouteTargetsNotesListRequest) Depth(depth int32) ApiIpamRouteTargetsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRouteTargetsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsNotesListExecute(r)
}

/*
IpamRouteTargetsNotesList Method for IpamRouteTargetsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsNotesListRequest
*/
func (a *IpamAPIService) IpamRouteTargetsNotesList(ctx context.Context, id string) ApiIpamRouteTargetsNotesListRequest {
	return ApiIpamRouteTargetsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamRouteTargetsNotesListExecute(r ApiIpamRouteTargetsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedRouteTargetRequest *PatchedRouteTargetRequest
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) PatchedRouteTargetRequest(patchedRouteTargetRequest PatchedRouteTargetRequest) ApiIpamRouteTargetsPartialUpdateRequest {
	r.patchedRouteTargetRequest = &patchedRouteTargetRequest
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsPartialUpdateExecute(r)
}

/*
IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

Partial update a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsPartialUpdate(ctx context.Context, id string) ApiIpamRouteTargetsPartialUpdateRequest {
	return ApiIpamRouteTargetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRouteTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamRouteTargetsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamRouteTargetsRetrieveRequest) Depth(depth int32) ApiIpamRouteTargetsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamRouteTargetsRetrieveRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsRetrieveExecute(r)
}

/*
IpamRouteTargetsRetrieve Method for IpamRouteTargetsRetrieve

Retrieve a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsRetrieveRequest
*/
func (a *IpamAPIService) IpamRouteTargetsRetrieve(ctx context.Context, id string) ApiIpamRouteTargetsRetrieveRequest {
	return ApiIpamRouteTargetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsRetrieveExecute(r ApiIpamRouteTargetsRetrieveRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	routeTargetRequest *RouteTargetRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamRouteTargetsUpdateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamRouteTargetsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsUpdateExecute(r)
}

/*
IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

Update a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsUpdate(ctx context.Context, id string) ApiIpamRouteTargetsUpdateRequest {
	return ApiIpamRouteTargetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamServicesBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamServicesBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesBulkDestroyExecute(r)
}

/*
IpamServicesBulkDestroy Method for IpamServicesBulkDestroy

Destroy a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamServicesBulkDestroy(ctx context.Context) ApiIpamServicesBulkDestroyRequest {
	return ApiIpamServicesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesBulkDestroyExecute(r ApiIpamServicesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableServiceRequest *[]PatchedBulkWritableServiceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesBulkPartialUpdateRequest) PatchedBulkWritableServiceRequest(patchedBulkWritableServiceRequest []PatchedBulkWritableServiceRequest) ApiIpamServicesBulkPartialUpdateRequest {
	r.patchedBulkWritableServiceRequest = &patchedBulkWritableServiceRequest
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkPartialUpdateExecute(r)
}

/*
IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

Partial update a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest {
	return ApiIpamServicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Service
func (a *IpamAPIService) IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableServiceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableServiceRequest *[]BulkWritableServiceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesBulkUpdateRequest) BulkWritableServiceRequest(bulkWritableServiceRequest []BulkWritableServiceRequest) ApiIpamServicesBulkUpdateRequest {
	r.bulkWritableServiceRequest = &bulkWritableServiceRequest
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkUpdateExecute(r)
}

/*
IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

Update a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest {
	return ApiIpamServicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Service
func (a *IpamAPIService) IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableServiceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	writableServiceRequest *WritableServiceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesCreateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesCreateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesCreateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesCreateExecute(r)
}

/*
IpamServicesCreate Method for IpamServicesCreate

Create one or more service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesCreateRequest
*/
func (a *IpamAPIService) IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest {
	return ApiIpamServicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesDestroyExecute(r)
}

/*
IpamServicesDestroy Method for IpamServicesDestroy

Destroy a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesDestroyRequest
*/
func (a *IpamAPIService) IpamServicesDestroy(ctx context.Context, id string) ApiIpamServicesDestroyRequest {
	return ApiIpamServicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesDestroyExecute(r ApiIpamServicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	device *[]string
	deviceIsnull *bool
	deviceN *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	ports *float32
	protocol *[]string
	protocolIc *[]string
	protocolIe *[]string
	protocolIew *[]string
	protocolIre *[]string
	protocolIsw *[]string
	protocolN *[]string
	protocolNic *[]string
	protocolNie *[]string
	protocolNiew *[]string
	protocolNire *[]string
	protocolNisw *[]string
	protocolNre *[]string
	protocolRe *[]string
	q *string
	sort *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	virtualMachine *[]string
	virtualMachineIsnull *bool
	virtualMachineN *[]string
	depth *int32
}

func (r ApiIpamServicesListRequest) Contacts(contacts []string) ApiIpamServicesListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamServicesListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamServicesListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamServicesListRequest) ContactsN(contactsN string) ApiIpamServicesListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamServicesListRequest) Created(created []time.Time) ApiIpamServicesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServicesListRequest) CreatedGt(createdGt []time.Time) ApiIpamServicesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamServicesListRequest) CreatedGte(createdGte []time.Time) ApiIpamServicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServicesListRequest) CreatedIsnull(createdIsnull bool) ApiIpamServicesListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamServicesListRequest) CreatedLt(createdLt []time.Time) ApiIpamServicesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamServicesListRequest) CreatedLte(createdLte []time.Time) ApiIpamServicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServicesListRequest) CreatedN(createdN []time.Time) ApiIpamServicesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamServicesListRequest) Device(device []string) ApiIpamServicesListRequest {
	r.device = &device
	return r
}

// Device (ID or name) is null
func (r ApiIpamServicesListRequest) DeviceIsnull(deviceIsnull bool) ApiIpamServicesListRequest {
	r.deviceIsnull = &deviceIsnull
	return r
}

func (r ApiIpamServicesListRequest) DeviceN(deviceN []string) ApiIpamServicesListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiIpamServicesListRequest) DynamicGroups(dynamicGroups []string) ApiIpamServicesListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamServicesListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamServicesListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamServicesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamServicesListRequest) Id(id []string) ApiIpamServicesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServicesListRequest) IdIc(idIc []string) ApiIpamServicesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamServicesListRequest) IdIe(idIe []string) ApiIpamServicesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamServicesListRequest) IdIew(idIew []string) ApiIpamServicesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamServicesListRequest) IdIre(idIre []string) ApiIpamServicesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamServicesListRequest) IdIsw(idIsw []string) ApiIpamServicesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamServicesListRequest) IdN(idN []string) ApiIpamServicesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamServicesListRequest) IdNic(idNic []string) ApiIpamServicesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamServicesListRequest) IdNie(idNie []string) ApiIpamServicesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamServicesListRequest) IdNiew(idNiew []string) ApiIpamServicesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamServicesListRequest) IdNire(idNire []string) ApiIpamServicesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamServicesListRequest) IdNisw(idNisw []string) ApiIpamServicesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamServicesListRequest) IdNre(idNre []string) ApiIpamServicesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamServicesListRequest) IdRe(idRe []string) ApiIpamServicesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamServicesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamServicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamServicesListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesListRequest) Limit(limit int32) ApiIpamServicesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServicesListRequest) Name(name []string) ApiIpamServicesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServicesListRequest) NameIc(nameIc []string) ApiIpamServicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServicesListRequest) NameIe(nameIe []string) ApiIpamServicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServicesListRequest) NameIew(nameIew []string) ApiIpamServicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServicesListRequest) NameIre(nameIre []string) ApiIpamServicesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamServicesListRequest) NameIsw(nameIsw []string) ApiIpamServicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServicesListRequest) NameN(nameN []string) ApiIpamServicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServicesListRequest) NameNic(nameNic []string) ApiIpamServicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServicesListRequest) NameNie(nameNie []string) ApiIpamServicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServicesListRequest) NameNiew(nameNiew []string) ApiIpamServicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServicesListRequest) NameNire(nameNire []string) ApiIpamServicesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamServicesListRequest) NameNisw(nameNisw []string) ApiIpamServicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamServicesListRequest) NameNre(nameNre []string) ApiIpamServicesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamServicesListRequest) NameRe(nameRe []string) ApiIpamServicesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesListRequest) Offset(offset int32) ApiIpamServicesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamServicesListRequest) Ports(ports float32) ApiIpamServicesListRequest {
	r.ports = &ports
	return r
}

func (r ApiIpamServicesListRequest) Protocol(protocol []string) ApiIpamServicesListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiIpamServicesListRequest) ProtocolIc(protocolIc []string) ApiIpamServicesListRequest {
	r.protocolIc = &protocolIc
	return r
}

func (r ApiIpamServicesListRequest) ProtocolIe(protocolIe []string) ApiIpamServicesListRequest {
	r.protocolIe = &protocolIe
	return r
}

func (r ApiIpamServicesListRequest) ProtocolIew(protocolIew []string) ApiIpamServicesListRequest {
	r.protocolIew = &protocolIew
	return r
}

func (r ApiIpamServicesListRequest) ProtocolIre(protocolIre []string) ApiIpamServicesListRequest {
	r.protocolIre = &protocolIre
	return r
}

func (r ApiIpamServicesListRequest) ProtocolIsw(protocolIsw []string) ApiIpamServicesListRequest {
	r.protocolIsw = &protocolIsw
	return r
}

func (r ApiIpamServicesListRequest) ProtocolN(protocolN []string) ApiIpamServicesListRequest {
	r.protocolN = &protocolN
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNic(protocolNic []string) ApiIpamServicesListRequest {
	r.protocolNic = &protocolNic
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNie(protocolNie []string) ApiIpamServicesListRequest {
	r.protocolNie = &protocolNie
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNiew(protocolNiew []string) ApiIpamServicesListRequest {
	r.protocolNiew = &protocolNiew
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNire(protocolNire []string) ApiIpamServicesListRequest {
	r.protocolNire = &protocolNire
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNisw(protocolNisw []string) ApiIpamServicesListRequest {
	r.protocolNisw = &protocolNisw
	return r
}

func (r ApiIpamServicesListRequest) ProtocolNre(protocolNre []string) ApiIpamServicesListRequest {
	r.protocolNre = &protocolNre
	return r
}

func (r ApiIpamServicesListRequest) ProtocolRe(protocolRe []string) ApiIpamServicesListRequest {
	r.protocolRe = &protocolRe
	return r
}

// Search
func (r ApiIpamServicesListRequest) Q(q string) ApiIpamServicesListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamServicesListRequest) Sort(sort string) ApiIpamServicesListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamServicesListRequest) Tags(tags []string) ApiIpamServicesListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamServicesListRequest) TagsIsnull(tagsIsnull bool) ApiIpamServicesListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamServicesListRequest) TagsN(tagsN []string) ApiIpamServicesListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamServicesListRequest) Teams(teams []string) ApiIpamServicesListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamServicesListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamServicesListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamServicesListRequest) TeamsN(teamsN string) ApiIpamServicesListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachine(virtualMachine []string) ApiIpamServicesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (ID or name) is null
func (r ApiIpamServicesListRequest) VirtualMachineIsnull(virtualMachineIsnull bool) ApiIpamServicesListRequest {
	r.virtualMachineIsnull = &virtualMachineIsnull
	return r
}

func (r ApiIpamServicesListRequest) VirtualMachineN(virtualMachineN []string) ApiIpamServicesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

// Serializer Depth
func (r ApiIpamServicesListRequest) Depth(depth int32) ApiIpamServicesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamServicesListRequest) Execute() (*PaginatedServiceList, *http.Response, error) {
	return r.ApiService.IpamServicesListExecute(r)
}

/*
IpamServicesList Method for IpamServicesList

Retrieve a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesListRequest
*/
func (a *IpamAPIService) IpamServicesList(ctx context.Context) ApiIpamServicesListRequest {
	return ApiIpamServicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedServiceList
func (a *IpamAPIService) IpamServicesListExecute(r ApiIpamServicesListRequest) (*PaginatedServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device__isnull", r.deviceIsnull, "form", "")
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ports", r.ports, "form", "")
	}
	if r.protocol != nil {
		t := *r.protocol
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", t, "form", "multi")
		}
	}
	if r.protocolIc != nil {
		t := *r.protocolIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", t, "form", "multi")
		}
	}
	if r.protocolIe != nil {
		t := *r.protocolIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", t, "form", "multi")
		}
	}
	if r.protocolIew != nil {
		t := *r.protocolIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", t, "form", "multi")
		}
	}
	if r.protocolIre != nil {
		t := *r.protocolIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ire", t, "form", "multi")
		}
	}
	if r.protocolIsw != nil {
		t := *r.protocolIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", t, "form", "multi")
		}
	}
	if r.protocolN != nil {
		t := *r.protocolN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", t, "form", "multi")
		}
	}
	if r.protocolNic != nil {
		t := *r.protocolNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", t, "form", "multi")
		}
	}
	if r.protocolNie != nil {
		t := *r.protocolNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", t, "form", "multi")
		}
	}
	if r.protocolNiew != nil {
		t := *r.protocolNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", t, "form", "multi")
		}
	}
	if r.protocolNire != nil {
		t := *r.protocolNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nire", t, "form", "multi")
		}
	}
	if r.protocolNisw != nil {
		t := *r.protocolNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", t, "form", "multi")
		}
	}
	if r.protocolNre != nil {
		t := *r.protocolNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nre", t, "form", "multi")
		}
	}
	if r.protocolRe != nil {
		t := *r.protocolRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__re", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__isnull", r.virtualMachineIsnull, "form", "")
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamServicesNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamServicesNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamServicesNotesCreateExecute(r)
}

/*
IpamServicesNotesCreate Method for IpamServicesNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesNotesCreateRequest
*/
func (a *IpamAPIService) IpamServicesNotesCreate(ctx context.Context, id string) ApiIpamServicesNotesCreateRequest {
	return ApiIpamServicesNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamServicesNotesCreateExecute(r ApiIpamServicesNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamServicesNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesNotesListRequest) Limit(limit int32) ApiIpamServicesNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesNotesListRequest) Offset(offset int32) ApiIpamServicesNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamServicesNotesListRequest) Depth(depth int32) ApiIpamServicesNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamServicesNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamServicesNotesListExecute(r)
}

/*
IpamServicesNotesList Method for IpamServicesNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesNotesListRequest
*/
func (a *IpamAPIService) IpamServicesNotesList(ctx context.Context, id string) ApiIpamServicesNotesListRequest {
	return ApiIpamServicesNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamServicesNotesListExecute(r ApiIpamServicesNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedWritableServiceRequest *PatchedWritableServiceRequest
}

func (r ApiIpamServicesPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) PatchedWritableServiceRequest(patchedWritableServiceRequest PatchedWritableServiceRequest) ApiIpamServicesPartialUpdateRequest {
	r.patchedWritableServiceRequest = &patchedWritableServiceRequest
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesPartialUpdateExecute(r)
}

/*
IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

Partial update a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesPartialUpdate(ctx context.Context, id string) ApiIpamServicesPartialUpdateRequest {
	return ApiIpamServicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamServicesRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamServicesRetrieveRequest) Depth(depth int32) ApiIpamServicesRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamServicesRetrieveRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesRetrieveExecute(r)
}

/*
IpamServicesRetrieve Method for IpamServicesRetrieve

Retrieve a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesRetrieveRequest
*/
func (a *IpamAPIService) IpamServicesRetrieve(ctx context.Context, id string) ApiIpamServicesRetrieveRequest {
	return ApiIpamServicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesRetrieveExecute(r ApiIpamServicesRetrieveRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	writableServiceRequest *WritableServiceRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamServicesUpdateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesUpdateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamServicesUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamServicesUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesUpdateExecute(r)
}

/*
IpamServicesUpdate Method for IpamServicesUpdate

Update a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesUpdateRequest
*/
func (a *IpamAPIService) IpamServicesUpdate(ctx context.Context, id string) ApiIpamServicesUpdateRequest {
	return ApiIpamServicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVlanGroupsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkDestroyExecute(r)
}

/*
IpamVlanGroupsBulkDestroy Method for IpamVlanGroupsBulkDestroy

Destroy a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkDestroy(ctx context.Context) ApiIpamVlanGroupsBulkDestroyRequest {
	return ApiIpamVlanGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsBulkDestroyExecute(r ApiIpamVlanGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVLANGroupRequest *[]PatchedBulkWritableVLANGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) PatchedBulkWritableVLANGroupRequest(patchedBulkWritableVLANGroupRequest []PatchedBulkWritableVLANGroupRequest) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.patchedBulkWritableVLANGroupRequest = &patchedBulkWritableVLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkPartialUpdateExecute(r)
}

/*
IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

Partial update a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	return ApiIpamVlanGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVLANGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVLANGroupRequest *[]BulkWritableVLANGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) BulkWritableVLANGroupRequest(bulkWritableVLANGroupRequest []BulkWritableVLANGroupRequest) ApiIpamVlanGroupsBulkUpdateRequest {
	r.bulkWritableVLANGroupRequest = &bulkWritableVLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkUpdateExecute(r)
}

/*
IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

Update a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest {
	return ApiIpamVlanGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVLANGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vLANGroupRequest *VLANGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsCreateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsCreateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsCreateExecute(r)
}

/*
IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

Create one or more VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest {
	return ApiIpamVlanGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsDestroyExecute(r)
}

/*
IpamVlanGroupsDestroy Method for IpamVlanGroupsDestroy

Destroy a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsDestroy(ctx context.Context, id string) ApiIpamVlanGroupsDestroyRequest {
	return ApiIpamVlanGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsDestroyExecute(r ApiIpamVlanGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationIsnull *bool
	locationN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	sort *string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	depth *int32
}

func (r ApiIpamVlanGroupsListRequest) Contacts(contacts []string) ApiIpamVlanGroupsListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamVlanGroupsListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamVlanGroupsListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamVlanGroupsListRequest) ContactsN(contactsN string) ApiIpamVlanGroupsListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Created(created []time.Time) ApiIpamVlanGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedIsnull(createdIsnull bool) ApiIpamVlanGroupsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedN(createdN []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Description(description []string) ApiIpamVlanGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIre(descriptionIre []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamVlanGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNire(descriptionNire []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNre(descriptionNre []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionRe(descriptionRe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DynamicGroups(dynamicGroups []string) ApiIpamVlanGroupsListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamVlanGroupsListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamVlanGroupsListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVlanGroupsListRequest) Id(id []string) ApiIpamVlanGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIc(idIc []string) ApiIpamVlanGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIe(idIe []string) ApiIpamVlanGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIew(idIew []string) ApiIpamVlanGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIre(idIre []string) ApiIpamVlanGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIsw(idIsw []string) ApiIpamVlanGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdN(idN []string) ApiIpamVlanGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNic(idNic []string) ApiIpamVlanGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNie(idNie []string) ApiIpamVlanGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNiew(idNiew []string) ApiIpamVlanGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNire(idNire []string) ApiIpamVlanGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNisw(idNisw []string) ApiIpamVlanGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNre(idNre []string) ApiIpamVlanGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdRe(idRe []string) ApiIpamVlanGroupsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsListRequest) Limit(limit int32) ApiIpamVlanGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanGroupsListRequest) Location(location []string) ApiIpamVlanGroupsListRequest {
	r.location = &location
	return r
}

// Location (name or ID) is null
func (r ApiIpamVlanGroupsListRequest) LocationIsnull(locationIsnull bool) ApiIpamVlanGroupsListRequest {
	r.locationIsnull = &locationIsnull
	return r
}

func (r ApiIpamVlanGroupsListRequest) LocationN(locationN []string) ApiIpamVlanGroupsListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Name(name []string) ApiIpamVlanGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIc(nameIc []string) ApiIpamVlanGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIe(nameIe []string) ApiIpamVlanGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIew(nameIew []string) ApiIpamVlanGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIre(nameIre []string) ApiIpamVlanGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIsw(nameIsw []string) ApiIpamVlanGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameN(nameN []string) ApiIpamVlanGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNic(nameNic []string) ApiIpamVlanGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNie(nameNie []string) ApiIpamVlanGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNiew(nameNiew []string) ApiIpamVlanGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNire(nameNire []string) ApiIpamVlanGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNisw(nameNisw []string) ApiIpamVlanGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNre(nameNre []string) ApiIpamVlanGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameRe(nameRe []string) ApiIpamVlanGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsListRequest) Offset(offset int32) ApiIpamVlanGroupsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVlanGroupsListRequest) Q(q string) ApiIpamVlanGroupsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanGroupsListRequest) Sort(sort string) ApiIpamVlanGroupsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVlanGroupsListRequest) Teams(teams []string) ApiIpamVlanGroupsListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamVlanGroupsListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamVlanGroupsListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamVlanGroupsListRequest) TeamsN(teamsN string) ApiIpamVlanGroupsListRequest {
	r.teamsN = &teamsN
	return r
}

// Serializer Depth
func (r ApiIpamVlanGroupsListRequest) Depth(depth int32) ApiIpamVlanGroupsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanGroupsListRequest) Execute() (*PaginatedVLANGroupList, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsListExecute(r)
}

/*
IpamVlanGroupsList Method for IpamVlanGroupsList

Retrieve a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest {
	return ApiIpamVlanGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANGroupList
func (a *IpamAPIService) IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*PaginatedVLANGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ire", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nire", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nre", t, "form", "multi")
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__re", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location__isnull", r.locationIsnull, "form", "")
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVlanGroupsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVlanGroupsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsNotesCreateExecute(r)
}

/*
IpamVlanGroupsNotesCreate Method for IpamVlanGroupsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsNotesCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsNotesCreate(ctx context.Context, id string) ApiIpamVlanGroupsNotesCreateRequest {
	return ApiIpamVlanGroupsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVlanGroupsNotesCreateExecute(r ApiIpamVlanGroupsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVlanGroupsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsNotesListRequest) Limit(limit int32) ApiIpamVlanGroupsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsNotesListRequest) Offset(offset int32) ApiIpamVlanGroupsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVlanGroupsNotesListRequest) Depth(depth int32) ApiIpamVlanGroupsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanGroupsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsNotesListExecute(r)
}

/*
IpamVlanGroupsNotesList Method for IpamVlanGroupsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsNotesListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsNotesList(ctx context.Context, id string) ApiIpamVlanGroupsNotesListRequest {
	return ApiIpamVlanGroupsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVlanGroupsNotesListExecute(r ApiIpamVlanGroupsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVLANGroupRequest *PatchedVLANGroupRequest
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) PatchedVLANGroupRequest(patchedVLANGroupRequest PatchedVLANGroupRequest) ApiIpamVlanGroupsPartialUpdateRequest {
	r.patchedVLANGroupRequest = &patchedVLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsPartialUpdateExecute(r)
}

/*
IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

Partial update a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsPartialUpdate(ctx context.Context, id string) ApiIpamVlanGroupsPartialUpdateRequest {
	return ApiIpamVlanGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVlanGroupsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVlanGroupsRetrieveRequest) Depth(depth int32) ApiIpamVlanGroupsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanGroupsRetrieveRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsRetrieveExecute(r)
}

/*
IpamVlanGroupsRetrieve Method for IpamVlanGroupsRetrieve

Retrieve a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanGroupsRetrieve(ctx context.Context, id string) ApiIpamVlanGroupsRetrieveRequest {
	return ApiIpamVlanGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsRetrieveExecute(r ApiIpamVlanGroupsRetrieveRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vLANGroupRequest *VLANGroupRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanGroupsUpdateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanGroupsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsUpdateExecute(r)
}

/*
IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

Update a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsUpdate(ctx context.Context, id string) ApiIpamVlanGroupsUpdateRequest {
	return ApiIpamVlanGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVlanLocationAssignmentsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsBulkDestroyExecute(r)
}

/*
IpamVlanLocationAssignmentsBulkDestroy Method for IpamVlanLocationAssignmentsBulkDestroy

Destroy a list of vlan location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanLocationAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkDestroy(ctx context.Context) ApiIpamVlanLocationAssignmentsBulkDestroyRequest {
	return ApiIpamVlanLocationAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkDestroyExecute(r ApiIpamVlanLocationAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVLANLocationAssignmentRequest *[]PatchedBulkWritableVLANLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest) PatchedBulkWritableVLANLocationAssignmentRequest(patchedBulkWritableVLANLocationAssignmentRequest []PatchedBulkWritableVLANLocationAssignmentRequest) ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest {
	r.patchedBulkWritableVLANLocationAssignmentRequest = &patchedBulkWritableVLANLocationAssignmentRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest) Execute() ([]VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamVlanLocationAssignmentsBulkPartialUpdate Method for IpamVlanLocationAssignmentsBulkPartialUpdate

Partial update a list of vlan location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest {
	return ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkPartialUpdateExecute(r ApiIpamVlanLocationAssignmentsBulkPartialUpdateRequest) ([]VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVLANLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVLANLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVLANLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVLANLocationAssignmentRequest *[]BulkWritableVLANLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsBulkUpdateRequest) BulkWritableVLANLocationAssignmentRequest(bulkWritableVLANLocationAssignmentRequest []BulkWritableVLANLocationAssignmentRequest) ApiIpamVlanLocationAssignmentsBulkUpdateRequest {
	r.bulkWritableVLANLocationAssignmentRequest = &bulkWritableVLANLocationAssignmentRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsBulkUpdateRequest) Execute() ([]VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsBulkUpdateExecute(r)
}

/*
IpamVlanLocationAssignmentsBulkUpdate Method for IpamVlanLocationAssignmentsBulkUpdate

Update a list of vlan location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanLocationAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkUpdate(ctx context.Context) ApiIpamVlanLocationAssignmentsBulkUpdateRequest {
	return ApiIpamVlanLocationAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsBulkUpdateExecute(r ApiIpamVlanLocationAssignmentsBulkUpdateRequest) ([]VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVLANLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVLANLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVLANLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vLANLocationAssignmentRequest *VLANLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsCreateRequest) VLANLocationAssignmentRequest(vLANLocationAssignmentRequest VLANLocationAssignmentRequest) ApiIpamVlanLocationAssignmentsCreateRequest {
	r.vLANLocationAssignmentRequest = &vLANLocationAssignmentRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsCreateRequest) Execute() (*VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsCreateExecute(r)
}

/*
IpamVlanLocationAssignmentsCreate Method for IpamVlanLocationAssignmentsCreate

Create one or more vlan location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanLocationAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsCreate(ctx context.Context) ApiIpamVlanLocationAssignmentsCreateRequest {
	return ApiIpamVlanLocationAssignmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsCreateExecute(r ApiIpamVlanLocationAssignmentsCreateRequest) (*VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vLANLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsDestroyExecute(r)
}

/*
IpamVlanLocationAssignmentsDestroy Method for IpamVlanLocationAssignmentsDestroy

Destroy a vlan location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsDestroy(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsDestroyRequest {
	return ApiIpamVlanLocationAssignmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanLocationAssignmentsDestroyExecute(r ApiIpamVlanLocationAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	created *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	offset *int32
	q *string
	sort *string
	vlan *[]string
	vlanN *[]string
	depth *int32
}

func (r ApiIpamVlanLocationAssignmentsListRequest) Created(created []time.Time) ApiIpamVlanLocationAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVlanLocationAssignmentsListRequest) Id(id []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdIc(idIc []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdIe(idIe []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdIew(idIew []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdIre(idIre []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdIsw(idIsw []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdN(idN []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNic(idNic []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNie(idNie []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNiew(idNiew []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNire(idNire []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNisw(idNisw []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdNre(idNre []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) IdRe(idRe []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanLocationAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanLocationAssignmentsListRequest) Limit(limit int32) ApiIpamVlanLocationAssignmentsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) Location(location []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.location = &location
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) LocationN(locationN []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.locationN = &locationN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanLocationAssignmentsListRequest) Offset(offset int32) ApiIpamVlanLocationAssignmentsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVlanLocationAssignmentsListRequest) Q(q string) ApiIpamVlanLocationAssignmentsListRequest {
	r.q = &q
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanLocationAssignmentsListRequest) Sort(sort string) ApiIpamVlanLocationAssignmentsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) Vlan(vlan []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.vlan = &vlan
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) VlanN(vlanN []string) ApiIpamVlanLocationAssignmentsListRequest {
	r.vlanN = &vlanN
	return r
}

// Serializer Depth
func (r ApiIpamVlanLocationAssignmentsListRequest) Depth(depth int32) ApiIpamVlanLocationAssignmentsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanLocationAssignmentsListRequest) Execute() (*PaginatedVLANLocationAssignmentList, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsListExecute(r)
}

/*
IpamVlanLocationAssignmentsList Method for IpamVlanLocationAssignmentsList

Retrieve a list of vlan location assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanLocationAssignmentsListRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsList(ctx context.Context) ApiIpamVlanLocationAssignmentsListRequest {
	return ApiIpamVlanLocationAssignmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANLocationAssignmentList
func (a *IpamAPIService) IpamVlanLocationAssignmentsListExecute(r ApiIpamVlanLocationAssignmentsListRequest) (*PaginatedVLANLocationAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANLocationAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.vlan != nil {
		t := *r.vlan
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan", t, "form", "multi")
		}
	}
	if r.vlanN != nil {
		t := *r.vlanN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVlanLocationAssignmentsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsNotesCreateExecute(r)
}

/*
IpamVlanLocationAssignmentsNotesCreate Method for IpamVlanLocationAssignmentsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsNotesCreateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsNotesCreate(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsNotesCreateRequest {
	return ApiIpamVlanLocationAssignmentsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVlanLocationAssignmentsNotesCreateExecute(r ApiIpamVlanLocationAssignmentsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVlanLocationAssignmentsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanLocationAssignmentsNotesListRequest) Limit(limit int32) ApiIpamVlanLocationAssignmentsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanLocationAssignmentsNotesListRequest) Offset(offset int32) ApiIpamVlanLocationAssignmentsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVlanLocationAssignmentsNotesListRequest) Depth(depth int32) ApiIpamVlanLocationAssignmentsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanLocationAssignmentsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsNotesListExecute(r)
}

/*
IpamVlanLocationAssignmentsNotesList Method for IpamVlanLocationAssignmentsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsNotesListRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsNotesList(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsNotesListRequest {
	return ApiIpamVlanLocationAssignmentsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVlanLocationAssignmentsNotesListExecute(r ApiIpamVlanLocationAssignmentsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVLANLocationAssignmentRequest *PatchedVLANLocationAssignmentRequest
}

func (r ApiIpamVlanLocationAssignmentsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsPartialUpdateRequest) PatchedVLANLocationAssignmentRequest(patchedVLANLocationAssignmentRequest PatchedVLANLocationAssignmentRequest) ApiIpamVlanLocationAssignmentsPartialUpdateRequest {
	r.patchedVLANLocationAssignmentRequest = &patchedVLANLocationAssignmentRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsPartialUpdateRequest) Execute() (*VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsPartialUpdateExecute(r)
}

/*
IpamVlanLocationAssignmentsPartialUpdate Method for IpamVlanLocationAssignmentsPartialUpdate

Partial update a vlan location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsPartialUpdate(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsPartialUpdateRequest {
	return ApiIpamVlanLocationAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsPartialUpdateExecute(r ApiIpamVlanLocationAssignmentsPartialUpdateRequest) (*VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVlanLocationAssignmentsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVlanLocationAssignmentsRetrieveRequest) Depth(depth int32) ApiIpamVlanLocationAssignmentsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlanLocationAssignmentsRetrieveRequest) Execute() (*VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsRetrieveExecute(r)
}

/*
IpamVlanLocationAssignmentsRetrieve Method for IpamVlanLocationAssignmentsRetrieve

Retrieve a vlan location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsRetrieve(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsRetrieveRequest {
	return ApiIpamVlanLocationAssignmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsRetrieveExecute(r ApiIpamVlanLocationAssignmentsRetrieveRequest) (*VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanLocationAssignmentsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vLANLocationAssignmentRequest *VLANLocationAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlanLocationAssignmentsUpdateRequest) VLANLocationAssignmentRequest(vLANLocationAssignmentRequest VLANLocationAssignmentRequest) ApiIpamVlanLocationAssignmentsUpdateRequest {
	r.vLANLocationAssignmentRequest = &vLANLocationAssignmentRequest
	return r
}

func (r ApiIpamVlanLocationAssignmentsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlanLocationAssignmentsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlanLocationAssignmentsUpdateRequest) Execute() (*VLANLocationAssignment, *http.Response, error) {
	return r.ApiService.IpamVlanLocationAssignmentsUpdateExecute(r)
}

/*
IpamVlanLocationAssignmentsUpdate Method for IpamVlanLocationAssignmentsUpdate

Update a vlan location assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vlan location assignment.
 @return ApiIpamVlanLocationAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamVlanLocationAssignmentsUpdate(ctx context.Context, id string) ApiIpamVlanLocationAssignmentsUpdateRequest {
	return ApiIpamVlanLocationAssignmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANLocationAssignment
func (a *IpamAPIService) IpamVlanLocationAssignmentsUpdateExecute(r ApiIpamVlanLocationAssignmentsUpdateRequest) (*VLANLocationAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANLocationAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanLocationAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-location-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANLocationAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vLANLocationAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANLocationAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVlansBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVlansBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansBulkDestroyExecute(r)
}

/*
IpamVlansBulkDestroy Method for IpamVlansBulkDestroy

Destroy a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlansBulkDestroy(ctx context.Context) ApiIpamVlansBulkDestroyRequest {
	return ApiIpamVlansBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansBulkDestroyExecute(r ApiIpamVlansBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVLANRequest *[]PatchedBulkWritableVLANRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansBulkPartialUpdateRequest) PatchedBulkWritableVLANRequest(patchedBulkWritableVLANRequest []PatchedBulkWritableVLANRequest) ApiIpamVlansBulkPartialUpdateRequest {
	r.patchedBulkWritableVLANRequest = &patchedBulkWritableVLANRequest
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkPartialUpdateExecute(r)
}

/*
IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

Partial update a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest {
	return ApiIpamVlansBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *IpamAPIService) IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVLANRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVLANRequest *[]BulkWritableVLANRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansBulkUpdateRequest) BulkWritableVLANRequest(bulkWritableVLANRequest []BulkWritableVLANRequest) ApiIpamVlansBulkUpdateRequest {
	r.bulkWritableVLANRequest = &bulkWritableVLANRequest
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkUpdateExecute(r)
}

/*
IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

Update a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest {
	return ApiIpamVlansBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *IpamAPIService) IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVLANRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vLANRequest *VLANRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansCreateRequest) VLANRequest(vLANRequest VLANRequest) ApiIpamVlansCreateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansCreateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansCreateExecute(r)
}

/*
IpamVlansCreate Method for IpamVlansCreate

Create one or more VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansCreateRequest
*/
func (a *IpamAPIService) IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest {
	return ApiIpamVlansCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansDestroyExecute(r)
}

/*
IpamVlansDestroy Method for IpamVlansDestroy

Destroy a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansDestroyRequest
*/
func (a *IpamAPIService) IpamVlansDestroy(ctx context.Context, id string) ApiIpamVlansDestroyRequest {
	return ApiIpamVlansDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansDestroyExecute(r ApiIpamVlansDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	availableOnDevice *[]string
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	dynamicGroups *[]string
	dynamicGroupsN *string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	locations *[]string
	locationsN *[]string
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	role *[]string
	roleIsnull *bool
	roleN *string
	sort *string
	status *[]string
	statusN *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	vid *[]int32
	vidGt *[]int32
	vidGte *[]int32
	vidLt *[]int32
	vidLte *[]int32
	vidN *[]int32
	vlanGroup *[]string
	vlanGroupIsnull *bool
	vlanGroupN *[]string
	depth *int32
}

// Device (ID)
func (r ApiIpamVlansListRequest) AvailableOnDevice(availableOnDevice []string) ApiIpamVlansListRequest {
	r.availableOnDevice = &availableOnDevice
	return r
}

func (r ApiIpamVlansListRequest) Contacts(contacts []string) ApiIpamVlansListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamVlansListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamVlansListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamVlansListRequest) ContactsN(contactsN string) ApiIpamVlansListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamVlansListRequest) Created(created []time.Time) ApiIpamVlansListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlansListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlansListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlansListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlansListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlansListRequest) CreatedIsnull(createdIsnull bool) ApiIpamVlansListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamVlansListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlansListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlansListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlansListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlansListRequest) CreatedN(createdN []time.Time) ApiIpamVlansListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlansListRequest) DynamicGroups(dynamicGroups []string) ApiIpamVlansListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamVlansListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamVlansListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamVlansListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVlansListRequest) Id(id []string) ApiIpamVlansListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlansListRequest) IdIc(idIc []string) ApiIpamVlansListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVlansListRequest) IdIe(idIe []string) ApiIpamVlansListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVlansListRequest) IdIew(idIew []string) ApiIpamVlansListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVlansListRequest) IdIre(idIre []string) ApiIpamVlansListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVlansListRequest) IdIsw(idIsw []string) ApiIpamVlansListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVlansListRequest) IdN(idN []string) ApiIpamVlansListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlansListRequest) IdNic(idNic []string) ApiIpamVlansListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVlansListRequest) IdNie(idNie []string) ApiIpamVlansListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVlansListRequest) IdNiew(idNiew []string) ApiIpamVlansListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVlansListRequest) IdNire(idNire []string) ApiIpamVlansListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVlansListRequest) IdNisw(idNisw []string) ApiIpamVlansListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVlansListRequest) IdNre(idNre []string) ApiIpamVlansListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVlansListRequest) IdRe(idRe []string) ApiIpamVlansListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVlansListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlansListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamVlansListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansListRequest) Limit(limit int32) ApiIpamVlansListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlansListRequest) Location(location []string) ApiIpamVlansListRequest {
	r.location = &location
	return r
}

func (r ApiIpamVlansListRequest) LocationN(locationN []string) ApiIpamVlansListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiIpamVlansListRequest) Locations(locations []string) ApiIpamVlansListRequest {
	r.locations = &locations
	return r
}

func (r ApiIpamVlansListRequest) LocationsN(locationsN []string) ApiIpamVlansListRequest {
	r.locationsN = &locationsN
	return r
}

func (r ApiIpamVlansListRequest) Name(name []string) ApiIpamVlansListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlansListRequest) NameIc(nameIc []string) ApiIpamVlansListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlansListRequest) NameIe(nameIe []string) ApiIpamVlansListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlansListRequest) NameIew(nameIew []string) ApiIpamVlansListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlansListRequest) NameIre(nameIre []string) ApiIpamVlansListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVlansListRequest) NameIsw(nameIsw []string) ApiIpamVlansListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlansListRequest) NameN(nameN []string) ApiIpamVlansListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlansListRequest) NameNic(nameNic []string) ApiIpamVlansListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlansListRequest) NameNie(nameNie []string) ApiIpamVlansListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlansListRequest) NameNiew(nameNiew []string) ApiIpamVlansListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlansListRequest) NameNire(nameNire []string) ApiIpamVlansListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVlansListRequest) NameNisw(nameNisw []string) ApiIpamVlansListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlansListRequest) NameNre(nameNre []string) ApiIpamVlansListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVlansListRequest) NameRe(nameRe []string) ApiIpamVlansListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansListRequest) Offset(offset int32) ApiIpamVlansListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVlansListRequest) Q(q string) ApiIpamVlansListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlansListRequest) Role(role []string) ApiIpamVlansListRequest {
	r.role = &role
	return r
}

// Role (name or ID) is null
func (r ApiIpamVlansListRequest) RoleIsnull(roleIsnull bool) ApiIpamVlansListRequest {
	r.roleIsnull = &roleIsnull
	return r
}

// Exclude Role (name or ID)
func (r ApiIpamVlansListRequest) RoleN(roleN string) ApiIpamVlansListRequest {
	r.roleN = &roleN
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlansListRequest) Sort(sort string) ApiIpamVlansListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVlansListRequest) Status(status []string) ApiIpamVlansListRequest {
	r.status = &status
	return r
}

// Exclude Status (name or ID)
func (r ApiIpamVlansListRequest) StatusN(statusN string) ApiIpamVlansListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamVlansListRequest) Tags(tags []string) ApiIpamVlansListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamVlansListRequest) TagsIsnull(tagsIsnull bool) ApiIpamVlansListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamVlansListRequest) TagsN(tagsN []string) ApiIpamVlansListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamVlansListRequest) Teams(teams []string) ApiIpamVlansListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamVlansListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamVlansListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamVlansListRequest) TeamsN(teamsN string) ApiIpamVlansListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamVlansListRequest) Tenant(tenant []string) ApiIpamVlansListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (name or ID) is null
func (r ApiIpamVlansListRequest) TenantIsnull(tenantIsnull bool) ApiIpamVlansListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiIpamVlansListRequest) TenantN(tenantN []string) ApiIpamVlansListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroup(tenantGroup []string) ApiIpamVlansListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (name or ID) is null
func (r ApiIpamVlansListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiIpamVlansListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVlansListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamVlansListRequest) TenantId(tenantId []*string) ApiIpamVlansListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead) is null
func (r ApiIpamVlansListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiIpamVlansListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Exclude Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamVlansListRequest) TenantIdN(tenantIdN []*string) ApiIpamVlansListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVlansListRequest) Vid(vid []int32) ApiIpamVlansListRequest {
	r.vid = &vid
	return r
}

func (r ApiIpamVlansListRequest) VidGt(vidGt []int32) ApiIpamVlansListRequest {
	r.vidGt = &vidGt
	return r
}

func (r ApiIpamVlansListRequest) VidGte(vidGte []int32) ApiIpamVlansListRequest {
	r.vidGte = &vidGte
	return r
}

func (r ApiIpamVlansListRequest) VidLt(vidLt []int32) ApiIpamVlansListRequest {
	r.vidLt = &vidLt
	return r
}

func (r ApiIpamVlansListRequest) VidLte(vidLte []int32) ApiIpamVlansListRequest {
	r.vidLte = &vidLte
	return r
}

func (r ApiIpamVlansListRequest) VidN(vidN []int32) ApiIpamVlansListRequest {
	r.vidN = &vidN
	return r
}

func (r ApiIpamVlansListRequest) VlanGroup(vlanGroup []string) ApiIpamVlansListRequest {
	r.vlanGroup = &vlanGroup
	return r
}

// VLAN Group (name or ID) is null
func (r ApiIpamVlansListRequest) VlanGroupIsnull(vlanGroupIsnull bool) ApiIpamVlansListRequest {
	r.vlanGroupIsnull = &vlanGroupIsnull
	return r
}

func (r ApiIpamVlansListRequest) VlanGroupN(vlanGroupN []string) ApiIpamVlansListRequest {
	r.vlanGroupN = &vlanGroupN
	return r
}

// Serializer Depth
func (r ApiIpamVlansListRequest) Depth(depth int32) ApiIpamVlansListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlansListRequest) Execute() (*PaginatedVLANList, *http.Response, error) {
	return r.ApiService.IpamVlansListExecute(r)
}

/*
IpamVlansList Method for IpamVlansList

Retrieve a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansListRequest
*/
func (a *IpamAPIService) IpamVlansList(ctx context.Context) ApiIpamVlansListRequest {
	return ApiIpamVlansListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANList
func (a *IpamAPIService) IpamVlansListExecute(r ApiIpamVlansListRequest) (*PaginatedVLANList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.availableOnDevice != nil {
		t := *r.availableOnDevice
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_device", t, "form", "multi")
		}
	}
	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations", t, "form", "multi")
		}
	}
	if r.locationsN != nil {
		t := *r.locationsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations__n", t, "form", "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__isnull", r.roleIsnull, "form", "")
	}
	if r.roleN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", r.roleN, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", r.statusN, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "form", "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "form", "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "form", "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.vid != nil {
		t := *r.vid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid", t, "form", "multi")
		}
	}
	if r.vidGt != nil {
		t := *r.vidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", t, "form", "multi")
		}
	}
	if r.vidGte != nil {
		t := *r.vidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", t, "form", "multi")
		}
	}
	if r.vidLt != nil {
		t := *r.vidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", t, "form", "multi")
		}
	}
	if r.vidLte != nil {
		t := *r.vidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", t, "form", "multi")
		}
	}
	if r.vidN != nil {
		t := *r.vidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", t, "form", "multi")
		}
	}
	if r.vlanGroup != nil {
		t := *r.vlanGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_group", t, "form", "multi")
		}
	}
	if r.vlanGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_group__isnull", r.vlanGroupIsnull, "form", "")
	}
	if r.vlanGroupN != nil {
		t := *r.vlanGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_group__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVlansNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVlansNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVlansNotesCreateExecute(r)
}

/*
IpamVlansNotesCreate Method for IpamVlansNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansNotesCreateRequest
*/
func (a *IpamAPIService) IpamVlansNotesCreate(ctx context.Context, id string) ApiIpamVlansNotesCreateRequest {
	return ApiIpamVlansNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVlansNotesCreateExecute(r ApiIpamVlansNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVlansNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansNotesListRequest) Limit(limit int32) ApiIpamVlansNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansNotesListRequest) Offset(offset int32) ApiIpamVlansNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVlansNotesListRequest) Depth(depth int32) ApiIpamVlansNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlansNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVlansNotesListExecute(r)
}

/*
IpamVlansNotesList Method for IpamVlansNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansNotesListRequest
*/
func (a *IpamAPIService) IpamVlansNotesList(ctx context.Context, id string) ApiIpamVlansNotesListRequest {
	return ApiIpamVlansNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVlansNotesListExecute(r ApiIpamVlansNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVLANRequest *PatchedVLANRequest
}

func (r ApiIpamVlansPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) PatchedVLANRequest(patchedVLANRequest PatchedVLANRequest) ApiIpamVlansPartialUpdateRequest {
	r.patchedVLANRequest = &patchedVLANRequest
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansPartialUpdateExecute(r)
}

/*
IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

Partial update a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansPartialUpdate(ctx context.Context, id string) ApiIpamVlansPartialUpdateRequest {
	return ApiIpamVlansPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVlansRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVlansRetrieveRequest) Depth(depth int32) ApiIpamVlansRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVlansRetrieveRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansRetrieveExecute(r)
}

/*
IpamVlansRetrieve Method for IpamVlansRetrieve

Retrieve a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansRetrieveRequest
*/
func (a *IpamAPIService) IpamVlansRetrieve(ctx context.Context, id string) ApiIpamVlansRetrieveRequest {
	return ApiIpamVlansRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansRetrieveExecute(r ApiIpamVlansRetrieveRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vLANRequest *VLANRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVlansUpdateRequest) VLANRequest(vLANRequest VLANRequest) ApiIpamVlansUpdateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVlansUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVlansUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansUpdateExecute(r)
}

/*
IpamVlansUpdate Method for IpamVlansUpdate

Update a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansUpdateRequest
*/
func (a *IpamAPIService) IpamVlansUpdate(ctx context.Context, id string) ApiIpamVlansUpdateRequest {
	return ApiIpamVlansUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVrfDeviceAssignmentsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsBulkDestroyExecute(r)
}

/*
IpamVrfDeviceAssignmentsBulkDestroy Method for IpamVrfDeviceAssignmentsBulkDestroy

Destroy a list of vrf device assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfDeviceAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkDestroy(ctx context.Context) ApiIpamVrfDeviceAssignmentsBulkDestroyRequest {
	return ApiIpamVrfDeviceAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkDestroyExecute(r ApiIpamVrfDeviceAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVRFDeviceAssignmentRequest *[]PatchedBulkWritableVRFDeviceAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest) PatchedBulkWritableVRFDeviceAssignmentRequest(patchedBulkWritableVRFDeviceAssignmentRequest []PatchedBulkWritableVRFDeviceAssignmentRequest) ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest {
	r.patchedBulkWritableVRFDeviceAssignmentRequest = &patchedBulkWritableVRFDeviceAssignmentRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest) Execute() ([]VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamVrfDeviceAssignmentsBulkPartialUpdate Method for IpamVrfDeviceAssignmentsBulkPartialUpdate

Partial update a list of vrf device assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest {
	return ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkPartialUpdateExecute(r ApiIpamVrfDeviceAssignmentsBulkPartialUpdateRequest) ([]VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVRFDeviceAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVRFDeviceAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVRFDeviceAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVRFDeviceAssignmentRequest *[]BulkWritableVRFDeviceAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsBulkUpdateRequest) BulkWritableVRFDeviceAssignmentRequest(bulkWritableVRFDeviceAssignmentRequest []BulkWritableVRFDeviceAssignmentRequest) ApiIpamVrfDeviceAssignmentsBulkUpdateRequest {
	r.bulkWritableVRFDeviceAssignmentRequest = &bulkWritableVRFDeviceAssignmentRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsBulkUpdateRequest) Execute() ([]VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsBulkUpdateExecute(r)
}

/*
IpamVrfDeviceAssignmentsBulkUpdate Method for IpamVrfDeviceAssignmentsBulkUpdate

Update a list of vrf device assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfDeviceAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkUpdate(ctx context.Context) ApiIpamVrfDeviceAssignmentsBulkUpdateRequest {
	return ApiIpamVrfDeviceAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsBulkUpdateExecute(r ApiIpamVrfDeviceAssignmentsBulkUpdateRequest) ([]VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVRFDeviceAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVRFDeviceAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVRFDeviceAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vRFDeviceAssignmentRequest *VRFDeviceAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsCreateRequest) VRFDeviceAssignmentRequest(vRFDeviceAssignmentRequest VRFDeviceAssignmentRequest) ApiIpamVrfDeviceAssignmentsCreateRequest {
	r.vRFDeviceAssignmentRequest = &vRFDeviceAssignmentRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsCreateRequest) Execute() (*VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsCreateExecute(r)
}

/*
IpamVrfDeviceAssignmentsCreate Method for IpamVrfDeviceAssignmentsCreate

Create one or more vrf device assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfDeviceAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsCreate(ctx context.Context) ApiIpamVrfDeviceAssignmentsCreateRequest {
	return ApiIpamVrfDeviceAssignmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsCreateExecute(r ApiIpamVrfDeviceAssignmentsCreateRequest) (*VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFDeviceAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vRFDeviceAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFDeviceAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsDestroyExecute(r)
}

/*
IpamVrfDeviceAssignmentsDestroy Method for IpamVrfDeviceAssignmentsDestroy

Destroy a vrf device assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsDestroy(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsDestroyRequest {
	return ApiIpamVrfDeviceAssignmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfDeviceAssignmentsDestroyExecute(r ApiIpamVrfDeviceAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	created *[]time.Time
	device *[]string
	deviceIsnull *bool
	deviceN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	limit *int32
	offset *int32
	sort *string
	virtualMachine *[]string
	virtualMachineIsnull *bool
	virtualMachineN *[]string
	vrf *string
	vrfN *string
	depth *int32
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) Created(created []time.Time) ApiIpamVrfDeviceAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) Device(device []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.device = &device
	return r
}

// Device (ID or name) is null
func (r ApiIpamVrfDeviceAssignmentsListRequest) DeviceIsnull(deviceIsnull bool) ApiIpamVrfDeviceAssignmentsListRequest {
	r.deviceIsnull = &deviceIsnull
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) DeviceN(deviceN []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVrfDeviceAssignmentsListRequest) Id(id []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdIc(idIc []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdIe(idIe []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdIew(idIew []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdIre(idIre []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdIsw(idIsw []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdN(idN []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNic(idNic []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNie(idNie []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNiew(idNiew []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNire(idNire []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNisw(idNisw []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdNre(idNre []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) IdRe(idRe []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVrfDeviceAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfDeviceAssignmentsListRequest) Limit(limit int32) ApiIpamVrfDeviceAssignmentsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfDeviceAssignmentsListRequest) Offset(offset int32) ApiIpamVrfDeviceAssignmentsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVrfDeviceAssignmentsListRequest) Sort(sort string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) VirtualMachine(virtualMachine []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual Machine (ID or name) is null
func (r ApiIpamVrfDeviceAssignmentsListRequest) VirtualMachineIsnull(virtualMachineIsnull bool) ApiIpamVrfDeviceAssignmentsListRequest {
	r.virtualMachineIsnull = &virtualMachineIsnull
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) VirtualMachineN(virtualMachineN []string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) Vrf(vrf string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.vrf = &vrf
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) VrfN(vrfN string) ApiIpamVrfDeviceAssignmentsListRequest {
	r.vrfN = &vrfN
	return r
}

// Serializer Depth
func (r ApiIpamVrfDeviceAssignmentsListRequest) Depth(depth int32) ApiIpamVrfDeviceAssignmentsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfDeviceAssignmentsListRequest) Execute() (*PaginatedVRFDeviceAssignmentList, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsListExecute(r)
}

/*
IpamVrfDeviceAssignmentsList Method for IpamVrfDeviceAssignmentsList

Retrieve a list of vrf device assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfDeviceAssignmentsListRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsList(ctx context.Context) ApiIpamVrfDeviceAssignmentsListRequest {
	return ApiIpamVrfDeviceAssignmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVRFDeviceAssignmentList
func (a *IpamAPIService) IpamVrfDeviceAssignmentsListExecute(r ApiIpamVrfDeviceAssignmentsListRequest) (*PaginatedVRFDeviceAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVRFDeviceAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device__isnull", r.deviceIsnull, "form", "")
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__isnull", r.virtualMachineIsnull, "form", "")
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", t, "form", "multi")
		}
	}
	if r.vrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", r.vrf, "form", "")
	}
	if r.vrfN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", r.vrfN, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVrfDeviceAssignmentsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsNotesCreateExecute(r)
}

/*
IpamVrfDeviceAssignmentsNotesCreate Method for IpamVrfDeviceAssignmentsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsNotesCreateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsNotesCreate(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsNotesCreateRequest {
	return ApiIpamVrfDeviceAssignmentsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVrfDeviceAssignmentsNotesCreateExecute(r ApiIpamVrfDeviceAssignmentsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVrfDeviceAssignmentsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfDeviceAssignmentsNotesListRequest) Limit(limit int32) ApiIpamVrfDeviceAssignmentsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfDeviceAssignmentsNotesListRequest) Offset(offset int32) ApiIpamVrfDeviceAssignmentsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVrfDeviceAssignmentsNotesListRequest) Depth(depth int32) ApiIpamVrfDeviceAssignmentsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfDeviceAssignmentsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsNotesListExecute(r)
}

/*
IpamVrfDeviceAssignmentsNotesList Method for IpamVrfDeviceAssignmentsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsNotesListRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsNotesList(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsNotesListRequest {
	return ApiIpamVrfDeviceAssignmentsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVrfDeviceAssignmentsNotesListExecute(r ApiIpamVrfDeviceAssignmentsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVRFDeviceAssignmentRequest *PatchedVRFDeviceAssignmentRequest
}

func (r ApiIpamVrfDeviceAssignmentsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsPartialUpdateRequest) PatchedVRFDeviceAssignmentRequest(patchedVRFDeviceAssignmentRequest PatchedVRFDeviceAssignmentRequest) ApiIpamVrfDeviceAssignmentsPartialUpdateRequest {
	r.patchedVRFDeviceAssignmentRequest = &patchedVRFDeviceAssignmentRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsPartialUpdateRequest) Execute() (*VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsPartialUpdateExecute(r)
}

/*
IpamVrfDeviceAssignmentsPartialUpdate Method for IpamVrfDeviceAssignmentsPartialUpdate

Partial update a vrf device assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsPartialUpdate(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsPartialUpdateRequest {
	return ApiIpamVrfDeviceAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsPartialUpdateExecute(r ApiIpamVrfDeviceAssignmentsPartialUpdateRequest) (*VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVRFDeviceAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVrfDeviceAssignmentsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVrfDeviceAssignmentsRetrieveRequest) Depth(depth int32) ApiIpamVrfDeviceAssignmentsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfDeviceAssignmentsRetrieveRequest) Execute() (*VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsRetrieveExecute(r)
}

/*
IpamVrfDeviceAssignmentsRetrieve Method for IpamVrfDeviceAssignmentsRetrieve

Retrieve a vrf device assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsRetrieve(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsRetrieveRequest {
	return ApiIpamVrfDeviceAssignmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsRetrieveExecute(r ApiIpamVrfDeviceAssignmentsRetrieveRequest) (*VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfDeviceAssignmentsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vRFDeviceAssignmentRequest *VRFDeviceAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfDeviceAssignmentsUpdateRequest) VRFDeviceAssignmentRequest(vRFDeviceAssignmentRequest VRFDeviceAssignmentRequest) ApiIpamVrfDeviceAssignmentsUpdateRequest {
	r.vRFDeviceAssignmentRequest = &vRFDeviceAssignmentRequest
	return r
}

func (r ApiIpamVrfDeviceAssignmentsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfDeviceAssignmentsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfDeviceAssignmentsUpdateRequest) Execute() (*VRFDeviceAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfDeviceAssignmentsUpdateExecute(r)
}

/*
IpamVrfDeviceAssignmentsUpdate Method for IpamVrfDeviceAssignmentsUpdate

Update a vrf device assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf device assignment.
 @return ApiIpamVrfDeviceAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamVrfDeviceAssignmentsUpdate(ctx context.Context, id string) ApiIpamVrfDeviceAssignmentsUpdateRequest {
	return ApiIpamVrfDeviceAssignmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFDeviceAssignment
func (a *IpamAPIService) IpamVrfDeviceAssignmentsUpdateExecute(r ApiIpamVrfDeviceAssignmentsUpdateRequest) (*VRFDeviceAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFDeviceAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfDeviceAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-device-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFDeviceAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vRFDeviceAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFDeviceAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVrfPrefixAssignmentsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsBulkDestroyExecute(r)
}

/*
IpamVrfPrefixAssignmentsBulkDestroy Method for IpamVrfPrefixAssignmentsBulkDestroy

Destroy a list of vrf prefix assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfPrefixAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkDestroy(ctx context.Context) ApiIpamVrfPrefixAssignmentsBulkDestroyRequest {
	return ApiIpamVrfPrefixAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkDestroyExecute(r ApiIpamVrfPrefixAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVRFPrefixAssignmentRequest *[]PatchedBulkWritableVRFPrefixAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest) PatchedBulkWritableVRFPrefixAssignmentRequest(patchedBulkWritableVRFPrefixAssignmentRequest []PatchedBulkWritableVRFPrefixAssignmentRequest) ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest {
	r.patchedBulkWritableVRFPrefixAssignmentRequest = &patchedBulkWritableVRFPrefixAssignmentRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest) Execute() ([]VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamVrfPrefixAssignmentsBulkPartialUpdate Method for IpamVrfPrefixAssignmentsBulkPartialUpdate

Partial update a list of vrf prefix assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest {
	return ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkPartialUpdateExecute(r ApiIpamVrfPrefixAssignmentsBulkPartialUpdateRequest) ([]VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVRFPrefixAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVRFPrefixAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVRFPrefixAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVRFPrefixAssignmentRequest *[]BulkWritableVRFPrefixAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsBulkUpdateRequest) BulkWritableVRFPrefixAssignmentRequest(bulkWritableVRFPrefixAssignmentRequest []BulkWritableVRFPrefixAssignmentRequest) ApiIpamVrfPrefixAssignmentsBulkUpdateRequest {
	r.bulkWritableVRFPrefixAssignmentRequest = &bulkWritableVRFPrefixAssignmentRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsBulkUpdateRequest) Execute() ([]VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsBulkUpdateExecute(r)
}

/*
IpamVrfPrefixAssignmentsBulkUpdate Method for IpamVrfPrefixAssignmentsBulkUpdate

Update a list of vrf prefix assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfPrefixAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkUpdate(ctx context.Context) ApiIpamVrfPrefixAssignmentsBulkUpdateRequest {
	return ApiIpamVrfPrefixAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsBulkUpdateExecute(r ApiIpamVrfPrefixAssignmentsBulkUpdateRequest) ([]VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVRFPrefixAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVRFPrefixAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVRFPrefixAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vRFPrefixAssignmentRequest *VRFPrefixAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsCreateRequest) VRFPrefixAssignmentRequest(vRFPrefixAssignmentRequest VRFPrefixAssignmentRequest) ApiIpamVrfPrefixAssignmentsCreateRequest {
	r.vRFPrefixAssignmentRequest = &vRFPrefixAssignmentRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsCreateRequest) Execute() (*VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsCreateExecute(r)
}

/*
IpamVrfPrefixAssignmentsCreate Method for IpamVrfPrefixAssignmentsCreate

Create one or more vrf prefix assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfPrefixAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsCreate(ctx context.Context) ApiIpamVrfPrefixAssignmentsCreateRequest {
	return ApiIpamVrfPrefixAssignmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsCreateExecute(r ApiIpamVrfPrefixAssignmentsCreateRequest) (*VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFPrefixAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vRFPrefixAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFPrefixAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsDestroyExecute(r)
}

/*
IpamVrfPrefixAssignmentsDestroy Method for IpamVrfPrefixAssignmentsDestroy

Destroy a vrf prefix assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsDestroy(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsDestroyRequest {
	return ApiIpamVrfPrefixAssignmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfPrefixAssignmentsDestroyExecute(r ApiIpamVrfPrefixAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	created *[]time.Time
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *[]time.Time
	limit *int32
	offset *int32
	prefix *[]string
	prefixN *[]string
	sort *string
	vrf *[]string
	vrfN *[]string
	depth *int32
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) Created(created []time.Time) ApiIpamVrfPrefixAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVrfPrefixAssignmentsListRequest) Id(id []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdIc(idIc []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdIe(idIe []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdIew(idIew []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdIre(idIre []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdIsw(idIsw []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdN(idN []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNic(idNic []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNie(idNie []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNiew(idNiew []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNire(idNire []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNisw(idNisw []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdNre(idNre []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) IdRe(idRe []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVrfPrefixAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfPrefixAssignmentsListRequest) Limit(limit int32) ApiIpamVrfPrefixAssignmentsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfPrefixAssignmentsListRequest) Offset(offset int32) ApiIpamVrfPrefixAssignmentsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) Prefix(prefix []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) PrefixN(prefixN []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.prefixN = &prefixN
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVrfPrefixAssignmentsListRequest) Sort(sort string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) Vrf(vrf []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.vrf = &vrf
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) VrfN(vrfN []string) ApiIpamVrfPrefixAssignmentsListRequest {
	r.vrfN = &vrfN
	return r
}

// Serializer Depth
func (r ApiIpamVrfPrefixAssignmentsListRequest) Depth(depth int32) ApiIpamVrfPrefixAssignmentsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfPrefixAssignmentsListRequest) Execute() (*PaginatedVRFPrefixAssignmentList, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsListExecute(r)
}

/*
IpamVrfPrefixAssignmentsList Method for IpamVrfPrefixAssignmentsList

Retrieve a list of vrf prefix assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfPrefixAssignmentsListRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsList(ctx context.Context) ApiIpamVrfPrefixAssignmentsListRequest {
	return ApiIpamVrfPrefixAssignmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVRFPrefixAssignmentList
func (a *IpamAPIService) IpamVrfPrefixAssignmentsListExecute(r ApiIpamVrfPrefixAssignmentsListRequest) (*PaginatedVRFPrefixAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVRFPrefixAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.prefixN != nil {
		t := *r.prefixN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix__n", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "form", "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVrfPrefixAssignmentsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsNotesCreateExecute(r)
}

/*
IpamVrfPrefixAssignmentsNotesCreate Method for IpamVrfPrefixAssignmentsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsNotesCreateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsNotesCreate(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsNotesCreateRequest {
	return ApiIpamVrfPrefixAssignmentsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVrfPrefixAssignmentsNotesCreateExecute(r ApiIpamVrfPrefixAssignmentsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVrfPrefixAssignmentsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfPrefixAssignmentsNotesListRequest) Limit(limit int32) ApiIpamVrfPrefixAssignmentsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfPrefixAssignmentsNotesListRequest) Offset(offset int32) ApiIpamVrfPrefixAssignmentsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVrfPrefixAssignmentsNotesListRequest) Depth(depth int32) ApiIpamVrfPrefixAssignmentsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfPrefixAssignmentsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsNotesListExecute(r)
}

/*
IpamVrfPrefixAssignmentsNotesList Method for IpamVrfPrefixAssignmentsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsNotesListRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsNotesList(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsNotesListRequest {
	return ApiIpamVrfPrefixAssignmentsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVrfPrefixAssignmentsNotesListExecute(r ApiIpamVrfPrefixAssignmentsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVRFPrefixAssignmentRequest *PatchedVRFPrefixAssignmentRequest
}

func (r ApiIpamVrfPrefixAssignmentsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsPartialUpdateRequest) PatchedVRFPrefixAssignmentRequest(patchedVRFPrefixAssignmentRequest PatchedVRFPrefixAssignmentRequest) ApiIpamVrfPrefixAssignmentsPartialUpdateRequest {
	r.patchedVRFPrefixAssignmentRequest = &patchedVRFPrefixAssignmentRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsPartialUpdateRequest) Execute() (*VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsPartialUpdateExecute(r)
}

/*
IpamVrfPrefixAssignmentsPartialUpdate Method for IpamVrfPrefixAssignmentsPartialUpdate

Partial update a vrf prefix assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsPartialUpdate(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsPartialUpdateRequest {
	return ApiIpamVrfPrefixAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsPartialUpdateExecute(r ApiIpamVrfPrefixAssignmentsPartialUpdateRequest) (*VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVRFPrefixAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVrfPrefixAssignmentsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVrfPrefixAssignmentsRetrieveRequest) Depth(depth int32) ApiIpamVrfPrefixAssignmentsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfPrefixAssignmentsRetrieveRequest) Execute() (*VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsRetrieveExecute(r)
}

/*
IpamVrfPrefixAssignmentsRetrieve Method for IpamVrfPrefixAssignmentsRetrieve

Retrieve a vrf prefix assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsRetrieve(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsRetrieveRequest {
	return ApiIpamVrfPrefixAssignmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsRetrieveExecute(r ApiIpamVrfPrefixAssignmentsRetrieveRequest) (*VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfPrefixAssignmentsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vRFPrefixAssignmentRequest *VRFPrefixAssignmentRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfPrefixAssignmentsUpdateRequest) VRFPrefixAssignmentRequest(vRFPrefixAssignmentRequest VRFPrefixAssignmentRequest) ApiIpamVrfPrefixAssignmentsUpdateRequest {
	r.vRFPrefixAssignmentRequest = &vRFPrefixAssignmentRequest
	return r
}

func (r ApiIpamVrfPrefixAssignmentsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfPrefixAssignmentsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfPrefixAssignmentsUpdateRequest) Execute() (*VRFPrefixAssignment, *http.Response, error) {
	return r.ApiService.IpamVrfPrefixAssignmentsUpdateExecute(r)
}

/*
IpamVrfPrefixAssignmentsUpdate Method for IpamVrfPrefixAssignmentsUpdate

Update a vrf prefix assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this vrf prefix assignment.
 @return ApiIpamVrfPrefixAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamVrfPrefixAssignmentsUpdate(ctx context.Context, id string) ApiIpamVrfPrefixAssignmentsUpdateRequest {
	return ApiIpamVrfPrefixAssignmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRFPrefixAssignment
func (a *IpamAPIService) IpamVrfPrefixAssignmentsUpdateExecute(r ApiIpamVrfPrefixAssignmentsUpdateRequest) (*VRFPrefixAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRFPrefixAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfPrefixAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrf-prefix-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFPrefixAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("vRFPrefixAssignmentRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFPrefixAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkOperationRequest *[]BulkOperationRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsBulkDestroyRequest) BulkOperationRequest(bulkOperationRequest []BulkOperationRequest) ApiIpamVrfsBulkDestroyRequest {
	r.bulkOperationRequest = &bulkOperationRequest
	return r
}

func (r ApiIpamVrfsBulkDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsBulkDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsBulkDestroyExecute(r)
}

/*
IpamVrfsBulkDestroy Method for IpamVrfsBulkDestroy

Destroy a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsBulkDestroy(ctx context.Context) ApiIpamVrfsBulkDestroyRequest {
	return ApiIpamVrfsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsBulkDestroyExecute(r ApiIpamVrfsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOperationRequest == nil {
		return nil, reportError("bulkOperationRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOperationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	patchedBulkWritableVRFRequest *[]PatchedBulkWritableVRFRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) PatchedBulkWritableVRFRequest(patchedBulkWritableVRFRequest []PatchedBulkWritableVRFRequest) ApiIpamVrfsBulkPartialUpdateRequest {
	r.patchedBulkWritableVRFRequest = &patchedBulkWritableVRFRequest
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsBulkPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkPartialUpdateExecute(r)
}

/*
IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

Partial update a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest {
	return ApiIpamVrfsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRF
func (a *IpamAPIService) IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedBulkWritableVRFRequest == nil {
		return localVarReturnValue, nil, reportError("patchedBulkWritableVRFRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBulkWritableVRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	bulkWritableVRFRequest *[]BulkWritableVRFRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsBulkUpdateRequest) BulkWritableVRFRequest(bulkWritableVRFRequest []BulkWritableVRFRequest) ApiIpamVrfsBulkUpdateRequest {
	r.bulkWritableVRFRequest = &bulkWritableVRFRequest
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsBulkUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkUpdateExecute(r)
}

/*
IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

Update a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest {
	return ApiIpamVrfsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRF
func (a *IpamAPIService) IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkWritableVRFRequest == nil {
		return localVarReturnValue, nil, reportError("bulkWritableVRFRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkWritableVRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	vRFRequest *VRFRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsCreateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsCreateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsCreateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsCreateExecute(r)
}

/*
IpamVrfsCreate Method for IpamVrfsCreate

Create one or more VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsCreateRequest
*/
func (a *IpamAPIService) IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest {
	return ApiIpamVrfsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsDestroyRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsDestroyExecute(r)
}

/*
IpamVrfsDestroy Method for IpamVrfsDestroy

Destroy a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsDestroy(ctx context.Context, id string) ApiIpamVrfsDestroyRequest {
	return ApiIpamVrfsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsDestroyExecute(r ApiIpamVrfsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	contacts *[]string
	contactsIsnull *bool
	contactsN *string
	created *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdIsnull *bool
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	device *[]string
	deviceN *[]string
	dynamicGroups *[]string
	dynamicGroupsN *string
	exportTargets *[]string
	exportTargetsN *[]string
	format *CircuitsCircuitTerminationsListFormatParameter
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	importTargets *[]string
	importTargetsN *[]string
	lastUpdated *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedIsnull *bool
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	namespace *[]string
	namespaceN *[]string
	offset *int32
	prefix *[]string
	prefixN *[]string
	q *string
	rd *[]string
	rdIc *[]string
	rdIe *[]string
	rdIew *[]string
	rdIre *[]string
	rdIsnull *bool
	rdIsw *[]string
	rdN *[]string
	rdNic *[]string
	rdNie *[]string
	rdNiew *[]string
	rdNire *[]string
	rdNisw *[]string
	rdNre *[]string
	rdRe *[]string
	sort *string
	status *[]string
	statusIsnull *bool
	statusN *string
	tags *[]string
	tagsIsnull *bool
	tagsN *[]string
	teams *[]string
	teamsIsnull *bool
	teamsN *string
	tenant *[]string
	tenantIsnull *bool
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupIsnull *bool
	tenantGroupN *[]string
	tenantId *[]*string
	tenantIdIsnull *bool
	tenantIdN *[]*string
	depth *int32
}

func (r ApiIpamVrfsListRequest) Contacts(contacts []string) ApiIpamVrfsListRequest {
	r.contacts = &contacts
	return r
}

// Contacts (name or ID) is null
func (r ApiIpamVrfsListRequest) ContactsIsnull(contactsIsnull bool) ApiIpamVrfsListRequest {
	r.contactsIsnull = &contactsIsnull
	return r
}

// Exclude Contacts (name or ID)
func (r ApiIpamVrfsListRequest) ContactsN(contactsN string) ApiIpamVrfsListRequest {
	r.contactsN = &contactsN
	return r
}

func (r ApiIpamVrfsListRequest) Created(created []time.Time) ApiIpamVrfsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVrfsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVrfsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedIsnull(createdIsnull bool) ApiIpamVrfsListRequest {
	r.createdIsnull = &createdIsnull
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVrfsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVrfsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedN(createdN []time.Time) ApiIpamVrfsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVrfsListRequest) Device(device []string) ApiIpamVrfsListRequest {
	r.device = &device
	return r
}

func (r ApiIpamVrfsListRequest) DeviceN(deviceN []string) ApiIpamVrfsListRequest {
	r.deviceN = &deviceN
	return r
}

func (r ApiIpamVrfsListRequest) DynamicGroups(dynamicGroups []string) ApiIpamVrfsListRequest {
	r.dynamicGroups = &dynamicGroups
	return r
}

// Exclude Dynamic groups (name or ID)
func (r ApiIpamVrfsListRequest) DynamicGroupsN(dynamicGroupsN string) ApiIpamVrfsListRequest {
	r.dynamicGroupsN = &dynamicGroupsN
	return r
}

func (r ApiIpamVrfsListRequest) ExportTargets(exportTargets []string) ApiIpamVrfsListRequest {
	r.exportTargets = &exportTargets
	return r
}

func (r ApiIpamVrfsListRequest) ExportTargetsN(exportTargetsN []string) ApiIpamVrfsListRequest {
	r.exportTargetsN = &exportTargetsN
	return r
}

func (r ApiIpamVrfsListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsListRequest {
	r.format = &format
	return r
}

// Unique object identifier, either a UUID primary key or a composite key.
func (r ApiIpamVrfsListRequest) Id(id []string) ApiIpamVrfsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfsListRequest) IdIc(idIc []string) ApiIpamVrfsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVrfsListRequest) IdIe(idIe []string) ApiIpamVrfsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVrfsListRequest) IdIew(idIew []string) ApiIpamVrfsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVrfsListRequest) IdIre(idIre []string) ApiIpamVrfsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVrfsListRequest) IdIsw(idIsw []string) ApiIpamVrfsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVrfsListRequest) IdN(idN []string) ApiIpamVrfsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVrfsListRequest) IdNic(idNic []string) ApiIpamVrfsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVrfsListRequest) IdNie(idNie []string) ApiIpamVrfsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVrfsListRequest) IdNiew(idNiew []string) ApiIpamVrfsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVrfsListRequest) IdNire(idNire []string) ApiIpamVrfsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVrfsListRequest) IdNisw(idNisw []string) ApiIpamVrfsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVrfsListRequest) IdNre(idNre []string) ApiIpamVrfsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVrfsListRequest) IdRe(idRe []string) ApiIpamVrfsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVrfsListRequest) ImportTargets(importTargets []string) ApiIpamVrfsListRequest {
	r.importTargets = &importTargets
	return r
}

func (r ApiIpamVrfsListRequest) ImportTargetsN(importTargetsN []string) ApiIpamVrfsListRequest {
	r.importTargetsN = &importTargetsN
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedIsnull(lastUpdatedIsnull bool) ApiIpamVrfsListRequest {
	r.lastUpdatedIsnull = &lastUpdatedIsnull
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsListRequest) Limit(limit int32) ApiIpamVrfsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVrfsListRequest) Name(name []string) ApiIpamVrfsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVrfsListRequest) NameIc(nameIc []string) ApiIpamVrfsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVrfsListRequest) NameIe(nameIe []string) ApiIpamVrfsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVrfsListRequest) NameIew(nameIew []string) ApiIpamVrfsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVrfsListRequest) NameIre(nameIre []string) ApiIpamVrfsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVrfsListRequest) NameIsw(nameIsw []string) ApiIpamVrfsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVrfsListRequest) NameN(nameN []string) ApiIpamVrfsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVrfsListRequest) NameNic(nameNic []string) ApiIpamVrfsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVrfsListRequest) NameNie(nameNie []string) ApiIpamVrfsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVrfsListRequest) NameNiew(nameNiew []string) ApiIpamVrfsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVrfsListRequest) NameNire(nameNire []string) ApiIpamVrfsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVrfsListRequest) NameNisw(nameNisw []string) ApiIpamVrfsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVrfsListRequest) NameNre(nameNre []string) ApiIpamVrfsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVrfsListRequest) NameRe(nameRe []string) ApiIpamVrfsListRequest {
	r.nameRe = &nameRe
	return r
}

func (r ApiIpamVrfsListRequest) Namespace(namespace []string) ApiIpamVrfsListRequest {
	r.namespace = &namespace
	return r
}

func (r ApiIpamVrfsListRequest) NamespaceN(namespaceN []string) ApiIpamVrfsListRequest {
	r.namespaceN = &namespaceN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsListRequest) Offset(offset int32) ApiIpamVrfsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamVrfsListRequest) Prefix(prefix []string) ApiIpamVrfsListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamVrfsListRequest) PrefixN(prefixN []string) ApiIpamVrfsListRequest {
	r.prefixN = &prefixN
	return r
}

// Search
func (r ApiIpamVrfsListRequest) Q(q string) ApiIpamVrfsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVrfsListRequest) Rd(rd []string) ApiIpamVrfsListRequest {
	r.rd = &rd
	return r
}

func (r ApiIpamVrfsListRequest) RdIc(rdIc []string) ApiIpamVrfsListRequest {
	r.rdIc = &rdIc
	return r
}

func (r ApiIpamVrfsListRequest) RdIe(rdIe []string) ApiIpamVrfsListRequest {
	r.rdIe = &rdIe
	return r
}

func (r ApiIpamVrfsListRequest) RdIew(rdIew []string) ApiIpamVrfsListRequest {
	r.rdIew = &rdIew
	return r
}

func (r ApiIpamVrfsListRequest) RdIre(rdIre []string) ApiIpamVrfsListRequest {
	r.rdIre = &rdIre
	return r
}

func (r ApiIpamVrfsListRequest) RdIsnull(rdIsnull bool) ApiIpamVrfsListRequest {
	r.rdIsnull = &rdIsnull
	return r
}

func (r ApiIpamVrfsListRequest) RdIsw(rdIsw []string) ApiIpamVrfsListRequest {
	r.rdIsw = &rdIsw
	return r
}

func (r ApiIpamVrfsListRequest) RdN(rdN []string) ApiIpamVrfsListRequest {
	r.rdN = &rdN
	return r
}

func (r ApiIpamVrfsListRequest) RdNic(rdNic []string) ApiIpamVrfsListRequest {
	r.rdNic = &rdNic
	return r
}

func (r ApiIpamVrfsListRequest) RdNie(rdNie []string) ApiIpamVrfsListRequest {
	r.rdNie = &rdNie
	return r
}

func (r ApiIpamVrfsListRequest) RdNiew(rdNiew []string) ApiIpamVrfsListRequest {
	r.rdNiew = &rdNiew
	return r
}

func (r ApiIpamVrfsListRequest) RdNire(rdNire []string) ApiIpamVrfsListRequest {
	r.rdNire = &rdNire
	return r
}

func (r ApiIpamVrfsListRequest) RdNisw(rdNisw []string) ApiIpamVrfsListRequest {
	r.rdNisw = &rdNisw
	return r
}

func (r ApiIpamVrfsListRequest) RdNre(rdNre []string) ApiIpamVrfsListRequest {
	r.rdNre = &rdNre
	return r
}

func (r ApiIpamVrfsListRequest) RdRe(rdRe []string) ApiIpamVrfsListRequest {
	r.rdRe = &rdRe
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVrfsListRequest) Sort(sort string) ApiIpamVrfsListRequest {
	r.sort = &sort
	return r
}

func (r ApiIpamVrfsListRequest) Status(status []string) ApiIpamVrfsListRequest {
	r.status = &status
	return r
}

// Status (name or ID) is null
func (r ApiIpamVrfsListRequest) StatusIsnull(statusIsnull bool) ApiIpamVrfsListRequest {
	r.statusIsnull = &statusIsnull
	return r
}

// Exclude Status (name or ID)
func (r ApiIpamVrfsListRequest) StatusN(statusN string) ApiIpamVrfsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamVrfsListRequest) Tags(tags []string) ApiIpamVrfsListRequest {
	r.tags = &tags
	return r
}

func (r ApiIpamVrfsListRequest) TagsIsnull(tagsIsnull bool) ApiIpamVrfsListRequest {
	r.tagsIsnull = &tagsIsnull
	return r
}

func (r ApiIpamVrfsListRequest) TagsN(tagsN []string) ApiIpamVrfsListRequest {
	r.tagsN = &tagsN
	return r
}

func (r ApiIpamVrfsListRequest) Teams(teams []string) ApiIpamVrfsListRequest {
	r.teams = &teams
	return r
}

// Teams (name or ID) is null
func (r ApiIpamVrfsListRequest) TeamsIsnull(teamsIsnull bool) ApiIpamVrfsListRequest {
	r.teamsIsnull = &teamsIsnull
	return r
}

// Exclude Teams (name or ID)
func (r ApiIpamVrfsListRequest) TeamsN(teamsN string) ApiIpamVrfsListRequest {
	r.teamsN = &teamsN
	return r
}

func (r ApiIpamVrfsListRequest) Tenant(tenant []string) ApiIpamVrfsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (name or ID) is null
func (r ApiIpamVrfsListRequest) TenantIsnull(tenantIsnull bool) ApiIpamVrfsListRequest {
	r.tenantIsnull = &tenantIsnull
	return r
}

func (r ApiIpamVrfsListRequest) TenantN(tenantN []string) ApiIpamVrfsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroup(tenantGroup []string) ApiIpamVrfsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (name or ID) is null
func (r ApiIpamVrfsListRequest) TenantGroupIsnull(tenantGroupIsnull bool) ApiIpamVrfsListRequest {
	r.tenantGroupIsnull = &tenantGroupIsnull
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVrfsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamVrfsListRequest) TenantId(tenantId []*string) ApiIpamVrfsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead) is null
func (r ApiIpamVrfsListRequest) TenantIdIsnull(tenantIdIsnull bool) ApiIpamVrfsListRequest {
	r.tenantIdIsnull = &tenantIdIsnull
	return r
}

// Exclude Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
func (r ApiIpamVrfsListRequest) TenantIdN(tenantIdN []*string) ApiIpamVrfsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Serializer Depth
func (r ApiIpamVrfsListRequest) Depth(depth int32) ApiIpamVrfsListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfsListRequest) Execute() (*PaginatedVRFList, *http.Response, error) {
	return r.ApiService.IpamVrfsListExecute(r)
}

/*
IpamVrfsList Method for IpamVrfsList

Retrieve a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsListRequest
*/
func (a *IpamAPIService) IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest {
	return ApiIpamVrfsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVRFList
func (a *IpamAPIService) IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*PaginatedVRFList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVRFList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contacts != nil {
		t := *r.contacts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contacts", t, "form", "multi")
		}
	}
	if r.contactsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__isnull", r.contactsIsnull, "form", "")
	}
	if r.contactsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contacts__n", r.contactsN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__isnull", r.createdIsnull, "form", "")
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "form", "multi")
		}
	}
	if r.dynamicGroups != nil {
		t := *r.dynamicGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups", t, "form", "multi")
		}
	}
	if r.dynamicGroupsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_groups__n", r.dynamicGroupsN, "form", "")
	}
	if r.exportTargets != nil {
		t := *r.exportTargets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_targets", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_targets", t, "form", "multi")
		}
	}
	if r.exportTargetsN != nil {
		t := *r.exportTargetsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_targets__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_targets__n", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ic", t, "form", "multi")
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ie", t, "form", "multi")
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__iew", t, "form", "multi")
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__ire", t, "form", "multi")
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__isw", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nic", t, "form", "multi")
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nie", t, "form", "multi")
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__niew", t, "form", "multi")
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nire", t, "form", "multi")
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nisw", t, "form", "multi")
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__nre", t, "form", "multi")
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__re", t, "form", "multi")
		}
	}
	if r.importTargets != nil {
		t := *r.importTargets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_targets", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_targets", t, "form", "multi")
		}
	}
	if r.importTargetsN != nil {
		t := *r.importTargetsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_targets__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_targets__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__isnull", r.lastUpdatedIsnull, "form", "")
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ire", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nire", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nre", t, "form", "multi")
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__re", t, "form", "multi")
		}
	}
	if r.namespace != nil {
		t := *r.namespace
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", t, "form", "multi")
		}
	}
	if r.namespaceN != nil {
		t := *r.namespaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "namespace__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.prefixN != nil {
		t := *r.prefixN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix__n", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rd != nil {
		t := *r.rd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd", t, "form", "multi")
		}
	}
	if r.rdIc != nil {
		t := *r.rdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", t, "form", "multi")
		}
	}
	if r.rdIe != nil {
		t := *r.rdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", t, "form", "multi")
		}
	}
	if r.rdIew != nil {
		t := *r.rdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", t, "form", "multi")
		}
	}
	if r.rdIre != nil {
		t := *r.rdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ire", t, "form", "multi")
		}
	}
	if r.rdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isnull", r.rdIsnull, "form", "")
	}
	if r.rdIsw != nil {
		t := *r.rdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", t, "form", "multi")
		}
	}
	if r.rdN != nil {
		t := *r.rdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", t, "form", "multi")
		}
	}
	if r.rdNic != nil {
		t := *r.rdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", t, "form", "multi")
		}
	}
	if r.rdNie != nil {
		t := *r.rdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", t, "form", "multi")
		}
	}
	if r.rdNiew != nil {
		t := *r.rdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", t, "form", "multi")
		}
	}
	if r.rdNire != nil {
		t := *r.rdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nire", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nire", t, "form", "multi")
		}
	}
	if r.rdNisw != nil {
		t := *r.rdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", t, "form", "multi")
		}
	}
	if r.rdNre != nil {
		t := *r.rdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nre", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nre", t, "form", "multi")
		}
	}
	if r.rdRe != nil {
		t := *r.rdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__re", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__re", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__isnull", r.statusIsnull, "form", "")
	}
	if r.statusN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", r.statusN, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.tagsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags__isnull", r.tagsIsnull, "form", "")
	}
	if r.tagsN != nil {
		t := *r.tagsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags__n", t, "form", "multi")
		}
	}
	if r.teams != nil {
		t := *r.teams
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teams", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teams", t, "form", "multi")
		}
	}
	if r.teamsIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__isnull", r.teamsIsnull, "form", "")
	}
	if r.teamsN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "teams__n", r.teamsN, "form", "")
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__isnull", r.tenantIsnull, "form", "")
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__isnull", r.tenantGroupIsnull, "form", "")
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__isnull", r.tenantIdIsnull, "form", "")
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsNotesCreateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	noteInputRequest *NoteInputRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsNotesCreateRequest) NoteInputRequest(noteInputRequest NoteInputRequest) ApiIpamVrfsNotesCreateRequest {
	r.noteInputRequest = &noteInputRequest
	return r
}

func (r ApiIpamVrfsNotesCreateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsNotesCreateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.IpamVrfsNotesCreateExecute(r)
}

/*
IpamVrfsNotesCreate Method for IpamVrfsNotesCreate

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsNotesCreateRequest
*/
func (a *IpamAPIService) IpamVrfsNotesCreate(ctx context.Context, id string) ApiIpamVrfsNotesCreateRequest {
	return ApiIpamVrfsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *IpamAPIService) IpamVrfsNotesCreateExecute(r ApiIpamVrfsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteInputRequest == nil {
		return localVarReturnValue, nil, reportError("noteInputRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noteInputRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsNotesListRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	limit *int32
	offset *int32
	depth *int32
}

func (r ApiIpamVrfsNotesListRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsNotesListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsNotesListRequest) Limit(limit int32) ApiIpamVrfsNotesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsNotesListRequest) Offset(offset int32) ApiIpamVrfsNotesListRequest {
	r.offset = &offset
	return r
}

// Serializer Depth
func (r ApiIpamVrfsNotesListRequest) Depth(depth int32) ApiIpamVrfsNotesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfsNotesListRequest) Execute() (*PaginatedNoteList, *http.Response, error) {
	return r.ApiService.IpamVrfsNotesListExecute(r)
}

/*
IpamVrfsNotesList Method for IpamVrfsNotesList

API methods for returning or creating notes on an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsNotesListRequest
*/
func (a *IpamAPIService) IpamVrfsNotesList(ctx context.Context, id string) ApiIpamVrfsNotesListRequest {
	return ApiIpamVrfsNotesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedNoteList
func (a *IpamAPIService) IpamVrfsNotesListExecute(r ApiIpamVrfsNotesListRequest) (*PaginatedNoteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedNoteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsNotesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	patchedVRFRequest *PatchedVRFRequest
}

func (r ApiIpamVrfsPartialUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) PatchedVRFRequest(patchedVRFRequest PatchedVRFRequest) ApiIpamVrfsPartialUpdateRequest {
	r.patchedVRFRequest = &patchedVRFRequest
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsPartialUpdateExecute(r)
}

/*
IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

Partial update a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsPartialUpdate(ctx context.Context, id string) ApiIpamVrfsPartialUpdateRequest {
	return ApiIpamVrfsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	format *CircuitsCircuitTerminationsListFormatParameter
	depth *int32
}

func (r ApiIpamVrfsRetrieveRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsRetrieveRequest {
	r.format = &format
	return r
}

// Serializer Depth
func (r ApiIpamVrfsRetrieveRequest) Depth(depth int32) ApiIpamVrfsRetrieveRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamVrfsRetrieveRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsRetrieveExecute(r)
}

/*
IpamVrfsRetrieve Method for IpamVrfsRetrieve

Retrieve a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsRetrieveRequest
*/
func (a *IpamAPIService) IpamVrfsRetrieve(ctx context.Context, id string) ApiIpamVrfsRetrieveRequest {
	return ApiIpamVrfsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsRetrieveExecute(r ApiIpamVrfsRetrieveRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	} else {
		var defaultValue int32 = 1
		r.depth = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamAPIService
	id string
	vRFRequest *VRFRequest
	format *CircuitsCircuitTerminationsListFormatParameter
}

func (r ApiIpamVrfsUpdateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsUpdateRequest) Format(format CircuitsCircuitTerminationsListFormatParameter) ApiIpamVrfsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiIpamVrfsUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsUpdateExecute(r)
}

/*
IpamVrfsUpdate Method for IpamVrfsUpdate

Update a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsUpdate(ctx context.Context, id string) ApiIpamVrfsUpdateRequest {
	return ApiIpamVrfsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
