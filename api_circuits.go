
/*
 * API Documentation
 *
 * Source of truth and network automation platform
 *
 * API version: 2.2.5 (2.2)
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nautobot

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type CircuitsApiService service
/*
CircuitsApiService
Destroy a list of circuit termination objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitTerminationsBulkDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a list of circuit termination objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCircuitTerminationRequest, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateOpts) ([]CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a list of circuit termination objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsBulkUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkUpdate(ctx context.Context, body []BulkWritableCircuitTerminationRequest, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsBulkUpdateOpts) ([]CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Create one or more circuit termination objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsCreate(ctx context.Context, body CircuitTerminationRequest, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsCreateOpts) (CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a circuit termination object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitTerminationsDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsDestroy(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a list of circuit termination objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsListOpts - Optional Parameters:
     * @param "Cable" (optional.Interface of []string) -  Cable
     * @param "CableIsnull" (optional.Bool) - 
     * @param "CableN" (optional.Interface of []string) -  Cable
     * @param "Circuit" (optional.Interface of []string) - 
     * @param "CircuitN" (optional.Interface of []string) - 
     * @param "Connected" (optional.Bool) -  Connected status (bool)
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCable" (optional.Bool) -  Has cable
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationIsnull" (optional.Bool) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PortSpeed" (optional.Interface of []int32) - 
     * @param "PortSpeedGt" (optional.Interface of []int32) - 
     * @param "PortSpeedGte" (optional.Interface of []int32) - 
     * @param "PortSpeedIsnull" (optional.Bool) - 
     * @param "PortSpeedLt" (optional.Interface of []int32) - 
     * @param "PortSpeedLte" (optional.Interface of []int32) - 
     * @param "PortSpeedN" (optional.Interface of []int32) - 
     * @param "PpInfo" (optional.Interface of []string) - 
     * @param "PpInfoIc" (optional.Interface of []string) - 
     * @param "PpInfoIe" (optional.Interface of []string) - 
     * @param "PpInfoIew" (optional.Interface of []string) - 
     * @param "PpInfoIre" (optional.Interface of []string) - 
     * @param "PpInfoIsw" (optional.Interface of []string) - 
     * @param "PpInfoN" (optional.Interface of []string) - 
     * @param "PpInfoNic" (optional.Interface of []string) - 
     * @param "PpInfoNie" (optional.Interface of []string) - 
     * @param "PpInfoNiew" (optional.Interface of []string) - 
     * @param "PpInfoNire" (optional.Interface of []string) - 
     * @param "PpInfoNisw" (optional.Interface of []string) - 
     * @param "PpInfoNre" (optional.Interface of []string) - 
     * @param "PpInfoRe" (optional.Interface of []string) - 
     * @param "ProviderNetwork" (optional.Interface of []string) - 
     * @param "ProviderNetworkIsnull" (optional.Bool) - 
     * @param "ProviderNetworkN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "TermSide" (optional.Interface of []string) - 
     * @param "TermSideIc" (optional.Interface of []string) - 
     * @param "TermSideIe" (optional.Interface of []string) - 
     * @param "TermSideIew" (optional.Interface of []string) - 
     * @param "TermSideIre" (optional.Interface of []string) - 
     * @param "TermSideIsw" (optional.Interface of []string) - 
     * @param "TermSideN" (optional.Interface of []string) - 
     * @param "TermSideNic" (optional.Interface of []string) - 
     * @param "TermSideNie" (optional.Interface of []string) - 
     * @param "TermSideNiew" (optional.Interface of []string) - 
     * @param "TermSideNire" (optional.Interface of []string) - 
     * @param "TermSideNisw" (optional.Interface of []string) - 
     * @param "TermSideNre" (optional.Interface of []string) - 
     * @param "TermSideRe" (optional.Interface of []string) - 
     * @param "UpstreamSpeed" (optional.Interface of []int32) - 
     * @param "UpstreamSpeedGt" (optional.Interface of []int32) - 
     * @param "UpstreamSpeedGte" (optional.Interface of []int32) - 
     * @param "UpstreamSpeedIsnull" (optional.Bool) - 
     * @param "UpstreamSpeedLt" (optional.Interface of []int32) - 
     * @param "UpstreamSpeedLte" (optional.Interface of []int32) - 
     * @param "UpstreamSpeedN" (optional.Interface of []int32) - 
     * @param "XconnectId" (optional.Interface of []string) - 
     * @param "XconnectIdIc" (optional.Interface of []string) - 
     * @param "XconnectIdIe" (optional.Interface of []string) - 
     * @param "XconnectIdIew" (optional.Interface of []string) - 
     * @param "XconnectIdIre" (optional.Interface of []string) - 
     * @param "XconnectIdIsw" (optional.Interface of []string) - 
     * @param "XconnectIdN" (optional.Interface of []string) - 
     * @param "XconnectIdNic" (optional.Interface of []string) - 
     * @param "XconnectIdNie" (optional.Interface of []string) - 
     * @param "XconnectIdNiew" (optional.Interface of []string) - 
     * @param "XconnectIdNire" (optional.Interface of []string) - 
     * @param "XconnectIdNisw" (optional.Interface of []string) - 
     * @param "XconnectIdNre" (optional.Interface of []string) - 
     * @param "XconnectIdRe" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCircuitTerminationList
*/

type CircuitsApiCircuitsCircuitTerminationsListOpts struct {
    Cable optional.Interface
    CableIsnull optional.Bool
    CableN optional.Interface
    Circuit optional.Interface
    CircuitN optional.Interface
    Connected optional.Bool
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    HasCable optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationIsnull optional.Bool
    LocationN optional.Interface
    Offset optional.Int32
    PortSpeed optional.Interface
    PortSpeedGt optional.Interface
    PortSpeedGte optional.Interface
    PortSpeedIsnull optional.Bool
    PortSpeedLt optional.Interface
    PortSpeedLte optional.Interface
    PortSpeedN optional.Interface
    PpInfo optional.Interface
    PpInfoIc optional.Interface
    PpInfoIe optional.Interface
    PpInfoIew optional.Interface
    PpInfoIre optional.Interface
    PpInfoIsw optional.Interface
    PpInfoN optional.Interface
    PpInfoNic optional.Interface
    PpInfoNie optional.Interface
    PpInfoNiew optional.Interface
    PpInfoNire optional.Interface
    PpInfoNisw optional.Interface
    PpInfoNre optional.Interface
    PpInfoRe optional.Interface
    ProviderNetwork optional.Interface
    ProviderNetworkIsnull optional.Bool
    ProviderNetworkN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    TermSide optional.Interface
    TermSideIc optional.Interface
    TermSideIe optional.Interface
    TermSideIew optional.Interface
    TermSideIre optional.Interface
    TermSideIsw optional.Interface
    TermSideN optional.Interface
    TermSideNic optional.Interface
    TermSideNie optional.Interface
    TermSideNiew optional.Interface
    TermSideNire optional.Interface
    TermSideNisw optional.Interface
    TermSideNre optional.Interface
    TermSideRe optional.Interface
    UpstreamSpeed optional.Interface
    UpstreamSpeedGt optional.Interface
    UpstreamSpeedGte optional.Interface
    UpstreamSpeedIsnull optional.Bool
    UpstreamSpeedLt optional.Interface
    UpstreamSpeedLte optional.Interface
    UpstreamSpeedN optional.Interface
    XconnectId optional.Interface
    XconnectIdIc optional.Interface
    XconnectIdIe optional.Interface
    XconnectIdIew optional.Interface
    XconnectIdIre optional.Interface
    XconnectIdIsw optional.Interface
    XconnectIdN optional.Interface
    XconnectIdNic optional.Interface
    XconnectIdNie optional.Interface
    XconnectIdNiew optional.Interface
    XconnectIdNire optional.Interface
    XconnectIdNisw optional.Interface
    XconnectIdNre optional.Interface
    XconnectIdRe optional.Interface
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsList(ctx context.Context, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsListOpts) (PaginatedCircuitTerminationList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCircuitTerminationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cable.IsSet() {
		localVarQueryParams.Add("cable", parameterToString(localVarOptionals.Cable.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CableIsnull.IsSet() {
		localVarQueryParams.Add("cable__isnull", parameterToString(localVarOptionals.CableIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableN.IsSet() {
		localVarQueryParams.Add("cable__n", parameterToString(localVarOptionals.CableN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Circuit.IsSet() {
		localVarQueryParams.Add("circuit", parameterToString(localVarOptionals.Circuit.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitN.IsSet() {
		localVarQueryParams.Add("circuit__n", parameterToString(localVarOptionals.CircuitN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Connected.IsSet() {
		localVarQueryParams.Add("connected", parameterToString(localVarOptionals.Connected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCable.IsSet() {
		localVarQueryParams.Add("has_cable", parameterToString(localVarOptionals.HasCable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIsnull.IsSet() {
		localVarQueryParams.Add("location__isnull", parameterToString(localVarOptionals.LocationIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeed.IsSet() {
		localVarQueryParams.Add("port_speed", parameterToString(localVarOptionals.PortSpeed.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedGt.IsSet() {
		localVarQueryParams.Add("port_speed__gt", parameterToString(localVarOptionals.PortSpeedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedGte.IsSet() {
		localVarQueryParams.Add("port_speed__gte", parameterToString(localVarOptionals.PortSpeedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedIsnull.IsSet() {
		localVarQueryParams.Add("port_speed__isnull", parameterToString(localVarOptionals.PortSpeedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedLt.IsSet() {
		localVarQueryParams.Add("port_speed__lt", parameterToString(localVarOptionals.PortSpeedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedLte.IsSet() {
		localVarQueryParams.Add("port_speed__lte", parameterToString(localVarOptionals.PortSpeedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortSpeedN.IsSet() {
		localVarQueryParams.Add("port_speed__n", parameterToString(localVarOptionals.PortSpeedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfo.IsSet() {
		localVarQueryParams.Add("pp_info", parameterToString(localVarOptionals.PpInfo.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoIc.IsSet() {
		localVarQueryParams.Add("pp_info__ic", parameterToString(localVarOptionals.PpInfoIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoIe.IsSet() {
		localVarQueryParams.Add("pp_info__ie", parameterToString(localVarOptionals.PpInfoIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoIew.IsSet() {
		localVarQueryParams.Add("pp_info__iew", parameterToString(localVarOptionals.PpInfoIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoIre.IsSet() {
		localVarQueryParams.Add("pp_info__ire", parameterToString(localVarOptionals.PpInfoIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoIsw.IsSet() {
		localVarQueryParams.Add("pp_info__isw", parameterToString(localVarOptionals.PpInfoIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoN.IsSet() {
		localVarQueryParams.Add("pp_info__n", parameterToString(localVarOptionals.PpInfoN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNic.IsSet() {
		localVarQueryParams.Add("pp_info__nic", parameterToString(localVarOptionals.PpInfoNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNie.IsSet() {
		localVarQueryParams.Add("pp_info__nie", parameterToString(localVarOptionals.PpInfoNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNiew.IsSet() {
		localVarQueryParams.Add("pp_info__niew", parameterToString(localVarOptionals.PpInfoNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNire.IsSet() {
		localVarQueryParams.Add("pp_info__nire", parameterToString(localVarOptionals.PpInfoNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNisw.IsSet() {
		localVarQueryParams.Add("pp_info__nisw", parameterToString(localVarOptionals.PpInfoNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoNre.IsSet() {
		localVarQueryParams.Add("pp_info__nre", parameterToString(localVarOptionals.PpInfoNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PpInfoRe.IsSet() {
		localVarQueryParams.Add("pp_info__re", parameterToString(localVarOptionals.PpInfoRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetwork.IsSet() {
		localVarQueryParams.Add("provider_network", parameterToString(localVarOptionals.ProviderNetwork.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworkIsnull.IsSet() {
		localVarQueryParams.Add("provider_network__isnull", parameterToString(localVarOptionals.ProviderNetworkIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworkN.IsSet() {
		localVarQueryParams.Add("provider_network__n", parameterToString(localVarOptionals.ProviderNetworkN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSide.IsSet() {
		localVarQueryParams.Add("term_side", parameterToString(localVarOptionals.TermSide.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideIc.IsSet() {
		localVarQueryParams.Add("term_side__ic", parameterToString(localVarOptionals.TermSideIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideIe.IsSet() {
		localVarQueryParams.Add("term_side__ie", parameterToString(localVarOptionals.TermSideIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideIew.IsSet() {
		localVarQueryParams.Add("term_side__iew", parameterToString(localVarOptionals.TermSideIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideIre.IsSet() {
		localVarQueryParams.Add("term_side__ire", parameterToString(localVarOptionals.TermSideIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideIsw.IsSet() {
		localVarQueryParams.Add("term_side__isw", parameterToString(localVarOptionals.TermSideIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideN.IsSet() {
		localVarQueryParams.Add("term_side__n", parameterToString(localVarOptionals.TermSideN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNic.IsSet() {
		localVarQueryParams.Add("term_side__nic", parameterToString(localVarOptionals.TermSideNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNie.IsSet() {
		localVarQueryParams.Add("term_side__nie", parameterToString(localVarOptionals.TermSideNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNiew.IsSet() {
		localVarQueryParams.Add("term_side__niew", parameterToString(localVarOptionals.TermSideNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNire.IsSet() {
		localVarQueryParams.Add("term_side__nire", parameterToString(localVarOptionals.TermSideNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNisw.IsSet() {
		localVarQueryParams.Add("term_side__nisw", parameterToString(localVarOptionals.TermSideNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideNre.IsSet() {
		localVarQueryParams.Add("term_side__nre", parameterToString(localVarOptionals.TermSideNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TermSideRe.IsSet() {
		localVarQueryParams.Add("term_side__re", parameterToString(localVarOptionals.TermSideRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeed.IsSet() {
		localVarQueryParams.Add("upstream_speed", parameterToString(localVarOptionals.UpstreamSpeed.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedGt.IsSet() {
		localVarQueryParams.Add("upstream_speed__gt", parameterToString(localVarOptionals.UpstreamSpeedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedGte.IsSet() {
		localVarQueryParams.Add("upstream_speed__gte", parameterToString(localVarOptionals.UpstreamSpeedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedIsnull.IsSet() {
		localVarQueryParams.Add("upstream_speed__isnull", parameterToString(localVarOptionals.UpstreamSpeedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedLt.IsSet() {
		localVarQueryParams.Add("upstream_speed__lt", parameterToString(localVarOptionals.UpstreamSpeedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedLte.IsSet() {
		localVarQueryParams.Add("upstream_speed__lte", parameterToString(localVarOptionals.UpstreamSpeedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.UpstreamSpeedN.IsSet() {
		localVarQueryParams.Add("upstream_speed__n", parameterToString(localVarOptionals.UpstreamSpeedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectId.IsSet() {
		localVarQueryParams.Add("xconnect_id", parameterToString(localVarOptionals.XconnectId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdIc.IsSet() {
		localVarQueryParams.Add("xconnect_id__ic", parameterToString(localVarOptionals.XconnectIdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdIe.IsSet() {
		localVarQueryParams.Add("xconnect_id__ie", parameterToString(localVarOptionals.XconnectIdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdIew.IsSet() {
		localVarQueryParams.Add("xconnect_id__iew", parameterToString(localVarOptionals.XconnectIdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdIre.IsSet() {
		localVarQueryParams.Add("xconnect_id__ire", parameterToString(localVarOptionals.XconnectIdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdIsw.IsSet() {
		localVarQueryParams.Add("xconnect_id__isw", parameterToString(localVarOptionals.XconnectIdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdN.IsSet() {
		localVarQueryParams.Add("xconnect_id__n", parameterToString(localVarOptionals.XconnectIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNic.IsSet() {
		localVarQueryParams.Add("xconnect_id__nic", parameterToString(localVarOptionals.XconnectIdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNie.IsSet() {
		localVarQueryParams.Add("xconnect_id__nie", parameterToString(localVarOptionals.XconnectIdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNiew.IsSet() {
		localVarQueryParams.Add("xconnect_id__niew", parameterToString(localVarOptionals.XconnectIdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNire.IsSet() {
		localVarQueryParams.Add("xconnect_id__nire", parameterToString(localVarOptionals.XconnectIdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNisw.IsSet() {
		localVarQueryParams.Add("xconnect_id__nisw", parameterToString(localVarOptionals.XconnectIdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdNre.IsSet() {
		localVarQueryParams.Add("xconnect_id__nre", parameterToString(localVarOptionals.XconnectIdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.XconnectIdRe.IsSet() {
		localVarQueryParams.Add("xconnect_id__re", parameterToString(localVarOptionals.XconnectIdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCircuitTerminationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type CircuitsApiCircuitsCircuitTerminationsNotesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type CircuitsApiCircuitsCircuitTerminationsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsNotesList(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a circuit termination object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedCircuitTerminationRequest) - 
     * @param "Format" (optional.String) - 
@return CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsPartialUpdate(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsPartialUpdateOpts) (CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a circuit termination object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsRetrieveOpts) (CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsTraceRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsTraceRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsTraceRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsTraceRetrieveOpts) (CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a circuit termination object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit termination.
 * @param optional nil or *CircuitsApiCircuitsCircuitTerminationsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CircuitTermination
*/

type CircuitsApiCircuitsCircuitTerminationsUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTerminationsUpdate(ctx context.Context, body CircuitTerminationRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitTerminationsUpdateOpts) (CircuitTermination, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitTermination
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitTermination
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a list of circuit type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitTypesBulkDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *CircuitsApiCircuitsCircuitTypesBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a list of circuit type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CircuitType
*/

type CircuitsApiCircuitsCircuitTypesBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCircuitTypeRequest, localVarOptionals *CircuitsApiCircuitsCircuitTypesBulkPartialUpdateOpts) ([]CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a list of circuit type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []CircuitType
*/

type CircuitsApiCircuitsCircuitTypesBulkUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesBulkUpdate(ctx context.Context, body []BulkWritableCircuitTypeRequest, localVarOptionals *CircuitsApiCircuitsCircuitTypesBulkUpdateOpts) ([]CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Create one or more circuit type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CircuitType
*/

type CircuitsApiCircuitsCircuitTypesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesCreate(ctx context.Context, body CircuitTypeRequest, localVarOptionals *CircuitsApiCircuitsCircuitTypesCreateOpts) (CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a circuit type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitTypesDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesDestroy(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a list of circuit type objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesListOpts - Optional Parameters:
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCircuitTypeList
*/

type CircuitsApiCircuitsCircuitTypesListOpts struct {
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Q optional.String
    Sort optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTypesList(ctx context.Context, localVarOptionals *CircuitsApiCircuitsCircuitTypesListOpts) (PaginatedCircuitTypeList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCircuitTypeList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCircuitTypeList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type CircuitsApiCircuitsCircuitTypesNotesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type CircuitsApiCircuitsCircuitTypesNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTypesNotesList(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a circuit type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedCircuitTypeRequest) - 
     * @param "Format" (optional.String) - 
@return CircuitType
*/

type CircuitsApiCircuitsCircuitTypesPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesPartialUpdate(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesPartialUpdateOpts) (CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a circuit type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return CircuitType
*/

type CircuitsApiCircuitsCircuitTypesRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitTypesRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesRetrieveOpts) (CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a circuit type object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit type.
 * @param optional nil or *CircuitsApiCircuitsCircuitTypesUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return CircuitType
*/

type CircuitsApiCircuitsCircuitTypesUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitTypesUpdate(ctx context.Context, body CircuitTypeRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitTypesUpdateOpts) (CircuitType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CircuitType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CircuitType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a list of circuit objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitsBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitsBulkDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *CircuitsApiCircuitsCircuitsBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a list of circuit objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitsBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Circuit
*/

type CircuitsApiCircuitsCircuitsBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableCircuitRequest, localVarOptionals *CircuitsApiCircuitsCircuitsBulkPartialUpdateOpts) ([]Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a list of circuit objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitsBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Circuit
*/

type CircuitsApiCircuitsCircuitsBulkUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsBulkUpdate(ctx context.Context, body []BulkWritableCircuitRequest, localVarOptionals *CircuitsApiCircuitsCircuitsBulkUpdateOpts) ([]Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Create one or more circuit objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsCircuitsCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Circuit
*/

type CircuitsApiCircuitsCircuitsCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsCreate(ctx context.Context, body CircuitRequest, localVarOptionals *CircuitsApiCircuitsCircuitsCreateOpts) (Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a circuit object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsCircuitsDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsDestroy(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitsDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a list of circuit objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CircuitsApiCircuitsCircuitsListOpts - Optional Parameters:
     * @param "Cid" (optional.Interface of []string) - 
     * @param "CidIc" (optional.Interface of []string) - 
     * @param "CidIe" (optional.Interface of []string) - 
     * @param "CidIew" (optional.Interface of []string) - 
     * @param "CidIre" (optional.Interface of []string) - 
     * @param "CidIsw" (optional.Interface of []string) - 
     * @param "CidN" (optional.Interface of []string) - 
     * @param "CidNic" (optional.Interface of []string) - 
     * @param "CidNie" (optional.Interface of []string) - 
     * @param "CidNiew" (optional.Interface of []string) - 
     * @param "CidNire" (optional.Interface of []string) - 
     * @param "CidNisw" (optional.Interface of []string) - 
     * @param "CidNre" (optional.Interface of []string) - 
     * @param "CidRe" (optional.Interface of []string) - 
     * @param "CircuitTerminationA" (optional.Interface of []string) -  Termination A (ID)
     * @param "CircuitTerminationAIsnull" (optional.Bool) - 
     * @param "CircuitTerminationAN" (optional.Interface of []string) -  Termination A (ID)
     * @param "CircuitTerminationZ" (optional.Interface of []string) -  Termination Z (ID)
     * @param "CircuitTerminationZIsnull" (optional.Bool) - 
     * @param "CircuitTerminationZN" (optional.Interface of []string) -  Termination Z (ID)
     * @param "CircuitTerminations" (optional.Interface of []string) - 
     * @param "CircuitTerminationsIsnull" (optional.Bool) - 
     * @param "CircuitTerminationsN" (optional.Interface of []string) - 
     * @param "CircuitType" (optional.Interface of []string) - 
     * @param "CircuitTypeN" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "CommitRate" (optional.Interface of []int32) - 
     * @param "CommitRateGt" (optional.Interface of []int32) - 
     * @param "CommitRateGte" (optional.Interface of []int32) - 
     * @param "CommitRateIsnull" (optional.Bool) - 
     * @param "CommitRateLt" (optional.Interface of []int32) - 
     * @param "CommitRateLte" (optional.Interface of []int32) - 
     * @param "CommitRateN" (optional.Interface of []int32) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasTerminations" (optional.Bool) -  Has terminations
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "InstallDate" (optional.Interface of []string) - 
     * @param "InstallDateGt" (optional.Interface of []string) - 
     * @param "InstallDateGte" (optional.Interface of []string) - 
     * @param "InstallDateIsnull" (optional.Bool) - 
     * @param "InstallDateLt" (optional.Interface of []string) - 
     * @param "InstallDateLte" (optional.Interface of []string) - 
     * @param "InstallDateN" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationIsnull" (optional.Bool) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Provider" (optional.Interface of []string) - 
     * @param "ProviderN" (optional.Interface of []string) - 
     * @param "ProviderNetwork" (optional.Interface of []string) - 
     * @param "ProviderNetworkIsnull" (optional.Bool) - 
     * @param "ProviderNetworkN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Status" (optional.Interface of []string) - 
     * @param "StatusN" (optional.Interface of []string) - 
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Tenant" (optional.Interface of []string) - 
     * @param "TenantIsnull" (optional.Bool) - 
     * @param "TenantN" (optional.Interface of []string) - 
     * @param "TenantGroup" (optional.Interface of []string) - 
     * @param "TenantGroupIsnull" (optional.Bool) - 
     * @param "TenantGroupN" (optional.Interface of []string) - 
     * @param "TenantId" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "TenantIdIsnull" (optional.Bool) - 
     * @param "TenantIdN" (optional.Interface of []string) -  Tenant (ID) (deprecated, use \&quot;tenant\&quot; filter instead)
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedCircuitList
*/

type CircuitsApiCircuitsCircuitsListOpts struct {
    Cid optional.Interface
    CidIc optional.Interface
    CidIe optional.Interface
    CidIew optional.Interface
    CidIre optional.Interface
    CidIsw optional.Interface
    CidN optional.Interface
    CidNic optional.Interface
    CidNie optional.Interface
    CidNiew optional.Interface
    CidNire optional.Interface
    CidNisw optional.Interface
    CidNre optional.Interface
    CidRe optional.Interface
    CircuitTerminationA optional.Interface
    CircuitTerminationAIsnull optional.Bool
    CircuitTerminationAN optional.Interface
    CircuitTerminationZ optional.Interface
    CircuitTerminationZIsnull optional.Bool
    CircuitTerminationZN optional.Interface
    CircuitTerminations optional.Interface
    CircuitTerminationsIsnull optional.Bool
    CircuitTerminationsN optional.Interface
    CircuitType optional.Interface
    CircuitTypeN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    CommitRate optional.Interface
    CommitRateGt optional.Interface
    CommitRateGte optional.Interface
    CommitRateIsnull optional.Bool
    CommitRateLt optional.Interface
    CommitRateLte optional.Interface
    CommitRateN optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    HasTerminations optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    InstallDate optional.Interface
    InstallDateGt optional.Interface
    InstallDateGte optional.Interface
    InstallDateIsnull optional.Bool
    InstallDateLt optional.Interface
    InstallDateLte optional.Interface
    InstallDateN optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationIsnull optional.Bool
    LocationN optional.Interface
    Offset optional.Int32
    Provider optional.Interface
    ProviderN optional.Interface
    ProviderNetwork optional.Interface
    ProviderNetworkIsnull optional.Bool
    ProviderNetworkN optional.Interface
    Q optional.String
    Sort optional.String
    Status optional.Interface
    StatusN optional.Interface
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Tenant optional.Interface
    TenantIsnull optional.Bool
    TenantN optional.Interface
    TenantGroup optional.Interface
    TenantGroupIsnull optional.Bool
    TenantGroupN optional.Interface
    TenantId optional.Interface
    TenantIdIsnull optional.Bool
    TenantIdN optional.Interface
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitsList(ctx context.Context, localVarOptionals *CircuitsApiCircuitsCircuitsListOpts) (PaginatedCircuitList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedCircuitList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Cid.IsSet() {
		localVarQueryParams.Add("cid", parameterToString(localVarOptionals.Cid.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidIc.IsSet() {
		localVarQueryParams.Add("cid__ic", parameterToString(localVarOptionals.CidIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidIe.IsSet() {
		localVarQueryParams.Add("cid__ie", parameterToString(localVarOptionals.CidIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidIew.IsSet() {
		localVarQueryParams.Add("cid__iew", parameterToString(localVarOptionals.CidIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidIre.IsSet() {
		localVarQueryParams.Add("cid__ire", parameterToString(localVarOptionals.CidIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidIsw.IsSet() {
		localVarQueryParams.Add("cid__isw", parameterToString(localVarOptionals.CidIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidN.IsSet() {
		localVarQueryParams.Add("cid__n", parameterToString(localVarOptionals.CidN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNic.IsSet() {
		localVarQueryParams.Add("cid__nic", parameterToString(localVarOptionals.CidNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNie.IsSet() {
		localVarQueryParams.Add("cid__nie", parameterToString(localVarOptionals.CidNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNiew.IsSet() {
		localVarQueryParams.Add("cid__niew", parameterToString(localVarOptionals.CidNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNire.IsSet() {
		localVarQueryParams.Add("cid__nire", parameterToString(localVarOptionals.CidNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNisw.IsSet() {
		localVarQueryParams.Add("cid__nisw", parameterToString(localVarOptionals.CidNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidNre.IsSet() {
		localVarQueryParams.Add("cid__nre", parameterToString(localVarOptionals.CidNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CidRe.IsSet() {
		localVarQueryParams.Add("cid__re", parameterToString(localVarOptionals.CidRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationA.IsSet() {
		localVarQueryParams.Add("circuit_termination_a", parameterToString(localVarOptionals.CircuitTerminationA.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationAIsnull.IsSet() {
		localVarQueryParams.Add("circuit_termination_a__isnull", parameterToString(localVarOptionals.CircuitTerminationAIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationAN.IsSet() {
		localVarQueryParams.Add("circuit_termination_a__n", parameterToString(localVarOptionals.CircuitTerminationAN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationZ.IsSet() {
		localVarQueryParams.Add("circuit_termination_z", parameterToString(localVarOptionals.CircuitTerminationZ.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationZIsnull.IsSet() {
		localVarQueryParams.Add("circuit_termination_z__isnull", parameterToString(localVarOptionals.CircuitTerminationZIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationZN.IsSet() {
		localVarQueryParams.Add("circuit_termination_z__n", parameterToString(localVarOptionals.CircuitTerminationZN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminations.IsSet() {
		localVarQueryParams.Add("circuit_terminations", parameterToString(localVarOptionals.CircuitTerminations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsIsnull.IsSet() {
		localVarQueryParams.Add("circuit_terminations__isnull", parameterToString(localVarOptionals.CircuitTerminationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsN.IsSet() {
		localVarQueryParams.Add("circuit_terminations__n", parameterToString(localVarOptionals.CircuitTerminationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitType.IsSet() {
		localVarQueryParams.Add("circuit_type", parameterToString(localVarOptionals.CircuitType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTypeN.IsSet() {
		localVarQueryParams.Add("circuit_type__n", parameterToString(localVarOptionals.CircuitTypeN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRate.IsSet() {
		localVarQueryParams.Add("commit_rate", parameterToString(localVarOptionals.CommitRate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateGt.IsSet() {
		localVarQueryParams.Add("commit_rate__gt", parameterToString(localVarOptionals.CommitRateGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateGte.IsSet() {
		localVarQueryParams.Add("commit_rate__gte", parameterToString(localVarOptionals.CommitRateGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateIsnull.IsSet() {
		localVarQueryParams.Add("commit_rate__isnull", parameterToString(localVarOptionals.CommitRateIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateLt.IsSet() {
		localVarQueryParams.Add("commit_rate__lt", parameterToString(localVarOptionals.CommitRateLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateLte.IsSet() {
		localVarQueryParams.Add("commit_rate__lte", parameterToString(localVarOptionals.CommitRateLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommitRateN.IsSet() {
		localVarQueryParams.Add("commit_rate__n", parameterToString(localVarOptionals.CommitRateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasTerminations.IsSet() {
		localVarQueryParams.Add("has_terminations", parameterToString(localVarOptionals.HasTerminations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDate.IsSet() {
		localVarQueryParams.Add("install_date", parameterToString(localVarOptionals.InstallDate.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateGt.IsSet() {
		localVarQueryParams.Add("install_date__gt", parameterToString(localVarOptionals.InstallDateGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateGte.IsSet() {
		localVarQueryParams.Add("install_date__gte", parameterToString(localVarOptionals.InstallDateGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateIsnull.IsSet() {
		localVarQueryParams.Add("install_date__isnull", parameterToString(localVarOptionals.InstallDateIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateLt.IsSet() {
		localVarQueryParams.Add("install_date__lt", parameterToString(localVarOptionals.InstallDateLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateLte.IsSet() {
		localVarQueryParams.Add("install_date__lte", parameterToString(localVarOptionals.InstallDateLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDateN.IsSet() {
		localVarQueryParams.Add("install_date__n", parameterToString(localVarOptionals.InstallDateN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIsnull.IsSet() {
		localVarQueryParams.Add("location__isnull", parameterToString(localVarOptionals.LocationIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Provider.IsSet() {
		localVarQueryParams.Add("provider", parameterToString(localVarOptionals.Provider.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderN.IsSet() {
		localVarQueryParams.Add("provider__n", parameterToString(localVarOptionals.ProviderN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetwork.IsSet() {
		localVarQueryParams.Add("provider_network", parameterToString(localVarOptionals.ProviderNetwork.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworkIsnull.IsSet() {
		localVarQueryParams.Add("provider_network__isnull", parameterToString(localVarOptionals.ProviderNetworkIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworkN.IsSet() {
		localVarQueryParams.Add("provider_network__n", parameterToString(localVarOptionals.ProviderNetworkN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.StatusN.IsSet() {
		localVarQueryParams.Add("status__n", parameterToString(localVarOptionals.StatusN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIsnull.IsSet() {
		localVarQueryParams.Add("tenant__isnull", parameterToString(localVarOptionals.TenantIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIsnull.IsSet() {
		localVarQueryParams.Add("tenant_group__isnull", parameterToString(localVarOptionals.TenantGroupIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdIsnull.IsSet() {
		localVarQueryParams.Add("tenant_id__isnull", parameterToString(localVarOptionals.TenantIdIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedCircuitList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type CircuitsApiCircuitsCircuitsNotesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitsNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type CircuitsApiCircuitsCircuitsNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitsNotesList(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitsNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a circuit object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedCircuitRequest) - 
     * @param "Format" (optional.String) - 
@return Circuit
*/

type CircuitsApiCircuitsCircuitsPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsPartialUpdate(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitsPartialUpdateOpts) (Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a circuit object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Circuit
*/

type CircuitsApiCircuitsCircuitsRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsCircuitsRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsCircuitsRetrieveOpts) (Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a circuit object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this circuit.
 * @param optional nil or *CircuitsApiCircuitsCircuitsUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Circuit
*/

type CircuitsApiCircuitsCircuitsUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsCircuitsUpdate(ctx context.Context, body CircuitRequest, id string, localVarOptionals *CircuitsApiCircuitsCircuitsUpdateOpts) (Circuit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Circuit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Circuit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a list of provider network objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsProviderNetworksBulkDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *CircuitsApiCircuitsProviderNetworksBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a list of provider network objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableProviderNetworkRequest, localVarOptionals *CircuitsApiCircuitsProviderNetworksBulkPartialUpdateOpts) ([]ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a list of provider network objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksBulkUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksBulkUpdate(ctx context.Context, body []BulkWritableProviderNetworkRequest, localVarOptionals *CircuitsApiCircuitsProviderNetworksBulkUpdateOpts) ([]ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Create one or more provider network objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksCreate(ctx context.Context, body ProviderNetworkRequest, localVarOptionals *CircuitsApiCircuitsProviderNetworksCreateOpts) (ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a provider network object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsProviderNetworksDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksDestroy(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a list of provider network objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksListOpts - Optional Parameters:
     * @param "CircuitTerminations" (optional.Interface of []string) -  Circuit Terminations (ID)
     * @param "CircuitTerminationsIsnull" (optional.Bool) - 
     * @param "CircuitTerminationsN" (optional.Interface of []string) -  Circuit Terminations (ID)
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Description" (optional.Interface of []string) - 
     * @param "DescriptionIc" (optional.Interface of []string) - 
     * @param "DescriptionIe" (optional.Interface of []string) - 
     * @param "DescriptionIew" (optional.Interface of []string) - 
     * @param "DescriptionIre" (optional.Interface of []string) - 
     * @param "DescriptionIsw" (optional.Interface of []string) - 
     * @param "DescriptionN" (optional.Interface of []string) - 
     * @param "DescriptionNic" (optional.Interface of []string) - 
     * @param "DescriptionNie" (optional.Interface of []string) - 
     * @param "DescriptionNiew" (optional.Interface of []string) - 
     * @param "DescriptionNire" (optional.Interface of []string) - 
     * @param "DescriptionNisw" (optional.Interface of []string) - 
     * @param "DescriptionNre" (optional.Interface of []string) - 
     * @param "DescriptionRe" (optional.Interface of []string) - 
     * @param "Format" (optional.String) - 
     * @param "HasCircuitTerminations" (optional.Bool) -  Has circuit terminations
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Provider" (optional.Interface of []string) - 
     * @param "ProviderN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedProviderNetworkList
*/

type CircuitsApiCircuitsProviderNetworksListOpts struct {
    CircuitTerminations optional.Interface
    CircuitTerminationsIsnull optional.Bool
    CircuitTerminationsN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Description optional.Interface
    DescriptionIc optional.Interface
    DescriptionIe optional.Interface
    DescriptionIew optional.Interface
    DescriptionIre optional.Interface
    DescriptionIsw optional.Interface
    DescriptionN optional.Interface
    DescriptionNic optional.Interface
    DescriptionNie optional.Interface
    DescriptionNiew optional.Interface
    DescriptionNire optional.Interface
    DescriptionNisw optional.Interface
    DescriptionNre optional.Interface
    DescriptionRe optional.Interface
    Format optional.String
    HasCircuitTerminations optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    Offset optional.Int32
    Provider optional.Interface
    ProviderN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProviderNetworksList(ctx context.Context, localVarOptionals *CircuitsApiCircuitsProviderNetworksListOpts) (PaginatedProviderNetworkList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedProviderNetworkList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CircuitTerminations.IsSet() {
		localVarQueryParams.Add("circuit_terminations", parameterToString(localVarOptionals.CircuitTerminations.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsIsnull.IsSet() {
		localVarQueryParams.Add("circuit_terminations__isnull", parameterToString(localVarOptionals.CircuitTerminationsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitTerminationsN.IsSet() {
		localVarQueryParams.Add("circuit_terminations__n", parameterToString(localVarOptionals.CircuitTerminationsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIc.IsSet() {
		localVarQueryParams.Add("description__ic", parameterToString(localVarOptionals.DescriptionIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIe.IsSet() {
		localVarQueryParams.Add("description__ie", parameterToString(localVarOptionals.DescriptionIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIew.IsSet() {
		localVarQueryParams.Add("description__iew", parameterToString(localVarOptionals.DescriptionIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIre.IsSet() {
		localVarQueryParams.Add("description__ire", parameterToString(localVarOptionals.DescriptionIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionIsw.IsSet() {
		localVarQueryParams.Add("description__isw", parameterToString(localVarOptionals.DescriptionIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionN.IsSet() {
		localVarQueryParams.Add("description__n", parameterToString(localVarOptionals.DescriptionN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNic.IsSet() {
		localVarQueryParams.Add("description__nic", parameterToString(localVarOptionals.DescriptionNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNie.IsSet() {
		localVarQueryParams.Add("description__nie", parameterToString(localVarOptionals.DescriptionNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNiew.IsSet() {
		localVarQueryParams.Add("description__niew", parameterToString(localVarOptionals.DescriptionNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNire.IsSet() {
		localVarQueryParams.Add("description__nire", parameterToString(localVarOptionals.DescriptionNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNisw.IsSet() {
		localVarQueryParams.Add("description__nisw", parameterToString(localVarOptionals.DescriptionNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionNre.IsSet() {
		localVarQueryParams.Add("description__nre", parameterToString(localVarOptionals.DescriptionNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DescriptionRe.IsSet() {
		localVarQueryParams.Add("description__re", parameterToString(localVarOptionals.DescriptionRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCircuitTerminations.IsSet() {
		localVarQueryParams.Add("has_circuit_terminations", parameterToString(localVarOptionals.HasCircuitTerminations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Provider.IsSet() {
		localVarQueryParams.Add("provider", parameterToString(localVarOptionals.Provider.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderN.IsSet() {
		localVarQueryParams.Add("provider__n", parameterToString(localVarOptionals.ProviderN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedProviderNetworkList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type CircuitsApiCircuitsProviderNetworksNotesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type CircuitsApiCircuitsProviderNetworksNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProviderNetworksNotesList(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a provider network object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedProviderNetworkRequest) - 
     * @param "Format" (optional.String) - 
@return ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksPartialUpdate(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksPartialUpdateOpts) (ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a provider network object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProviderNetworksRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksRetrieveOpts) (ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a provider network object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this provider network.
 * @param optional nil or *CircuitsApiCircuitsProviderNetworksUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return ProviderNetwork
*/

type CircuitsApiCircuitsProviderNetworksUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProviderNetworksUpdate(ctx context.Context, body ProviderNetworkRequest, id string, localVarOptionals *CircuitsApiCircuitsProviderNetworksUpdateOpts) (ProviderNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProviderNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProviderNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a list of provider objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProvidersBulkDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsProvidersBulkDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersBulkDestroy(ctx context.Context, body []BulkOperationRequest, localVarOptionals *CircuitsApiCircuitsProvidersBulkDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a list of provider objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProvidersBulkPartialUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Provider
*/

type CircuitsApiCircuitsProvidersBulkPartialUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersBulkPartialUpdate(ctx context.Context, body []PatchedBulkWritableProviderRequest, localVarOptionals *CircuitsApiCircuitsProvidersBulkPartialUpdateOpts) ([]Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a list of provider objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProvidersBulkUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return []Provider
*/

type CircuitsApiCircuitsProvidersBulkUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersBulkUpdate(ctx context.Context, body []BulkWritableProviderRequest, localVarOptionals *CircuitsApiCircuitsProvidersBulkUpdateOpts) ([]Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Create one or more provider objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *CircuitsApiCircuitsProvidersCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Provider
*/

type CircuitsApiCircuitsProvidersCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersCreate(ctx context.Context, body ProviderRequest, localVarOptionals *CircuitsApiCircuitsProvidersCreateOpts) (Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Destroy a provider object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersDestroyOpts - Optional Parameters:
     * @param "Format" (optional.String) - 

*/

type CircuitsApiCircuitsProvidersDestroyOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersDestroy(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProvidersDestroyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a list of provider objects.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CircuitsApiCircuitsProvidersListOpts - Optional Parameters:
     * @param "Account" (optional.Interface of []string) - 
     * @param "AccountIc" (optional.Interface of []string) - 
     * @param "AccountIe" (optional.Interface of []string) - 
     * @param "AccountIew" (optional.Interface of []string) - 
     * @param "AccountIre" (optional.Interface of []string) - 
     * @param "AccountIsw" (optional.Interface of []string) - 
     * @param "AccountN" (optional.Interface of []string) - 
     * @param "AccountNic" (optional.Interface of []string) - 
     * @param "AccountNie" (optional.Interface of []string) - 
     * @param "AccountNiew" (optional.Interface of []string) - 
     * @param "AccountNire" (optional.Interface of []string) - 
     * @param "AccountNisw" (optional.Interface of []string) - 
     * @param "AccountNre" (optional.Interface of []string) - 
     * @param "AccountRe" (optional.Interface of []string) - 
     * @param "AdminContact" (optional.Interface of []string) - 
     * @param "AdminContactIc" (optional.Interface of []string) - 
     * @param "AdminContactIe" (optional.Interface of []string) - 
     * @param "AdminContactIew" (optional.Interface of []string) - 
     * @param "AdminContactIre" (optional.Interface of []string) - 
     * @param "AdminContactIsw" (optional.Interface of []string) - 
     * @param "AdminContactN" (optional.Interface of []string) - 
     * @param "AdminContactNic" (optional.Interface of []string) - 
     * @param "AdminContactNie" (optional.Interface of []string) - 
     * @param "AdminContactNiew" (optional.Interface of []string) - 
     * @param "AdminContactNire" (optional.Interface of []string) - 
     * @param "AdminContactNisw" (optional.Interface of []string) - 
     * @param "AdminContactNre" (optional.Interface of []string) - 
     * @param "AdminContactRe" (optional.Interface of []string) - 
     * @param "Asn" (optional.Interface of []int32) - 
     * @param "AsnGt" (optional.Interface of []int32) - 
     * @param "AsnGte" (optional.Interface of []int32) - 
     * @param "AsnIsnull" (optional.Bool) - 
     * @param "AsnLt" (optional.Interface of []int32) - 
     * @param "AsnLte" (optional.Interface of []int32) - 
     * @param "AsnN" (optional.Interface of []int32) - 
     * @param "Circuits" (optional.Interface of []string) - 
     * @param "CircuitsIsnull" (optional.Bool) - 
     * @param "CircuitsN" (optional.Interface of []string) - 
     * @param "Comments" (optional.Interface of []string) - 
     * @param "CommentsIc" (optional.Interface of []string) - 
     * @param "CommentsIe" (optional.Interface of []string) - 
     * @param "CommentsIew" (optional.Interface of []string) - 
     * @param "CommentsIre" (optional.Interface of []string) - 
     * @param "CommentsIsw" (optional.Interface of []string) - 
     * @param "CommentsN" (optional.Interface of []string) - 
     * @param "CommentsNic" (optional.Interface of []string) - 
     * @param "CommentsNie" (optional.Interface of []string) - 
     * @param "CommentsNiew" (optional.Interface of []string) - 
     * @param "CommentsNire" (optional.Interface of []string) - 
     * @param "CommentsNisw" (optional.Interface of []string) - 
     * @param "CommentsNre" (optional.Interface of []string) - 
     * @param "CommentsRe" (optional.Interface of []string) - 
     * @param "Created" (optional.Interface of []time.Time) - 
     * @param "CreatedGt" (optional.Interface of []time.Time) - 
     * @param "CreatedGte" (optional.Interface of []time.Time) - 
     * @param "CreatedIsnull" (optional.Bool) - 
     * @param "CreatedLt" (optional.Interface of []time.Time) - 
     * @param "CreatedLte" (optional.Interface of []time.Time) - 
     * @param "CreatedN" (optional.Interface of []time.Time) - 
     * @param "Format" (optional.String) - 
     * @param "HasCircuits" (optional.Bool) -  Has circuits
     * @param "HasProviderNetworks" (optional.Bool) -  Has provider networks
     * @param "Id" (optional.Interface of []string) -  Unique object identifier, either a UUID primary key or a composite key.
     * @param "IdIc" (optional.Interface of []string) - 
     * @param "IdIe" (optional.Interface of []string) - 
     * @param "IdIew" (optional.Interface of []string) - 
     * @param "IdIre" (optional.Interface of []string) - 
     * @param "IdIsw" (optional.Interface of []string) - 
     * @param "IdN" (optional.Interface of []string) - 
     * @param "IdNic" (optional.Interface of []string) - 
     * @param "IdNie" (optional.Interface of []string) - 
     * @param "IdNiew" (optional.Interface of []string) - 
     * @param "IdNire" (optional.Interface of []string) - 
     * @param "IdNisw" (optional.Interface of []string) - 
     * @param "IdNre" (optional.Interface of []string) - 
     * @param "IdRe" (optional.Interface of []string) - 
     * @param "LastUpdated" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedGte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedIsnull" (optional.Bool) - 
     * @param "LastUpdatedLt" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedLte" (optional.Interface of []time.Time) - 
     * @param "LastUpdatedN" (optional.Interface of []time.Time) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Location" (optional.Interface of []string) - 
     * @param "LocationIsnull" (optional.Bool) - 
     * @param "LocationN" (optional.Interface of []string) - 
     * @param "Name" (optional.Interface of []string) - 
     * @param "NameIc" (optional.Interface of []string) - 
     * @param "NameIe" (optional.Interface of []string) - 
     * @param "NameIew" (optional.Interface of []string) - 
     * @param "NameIre" (optional.Interface of []string) - 
     * @param "NameIsw" (optional.Interface of []string) - 
     * @param "NameN" (optional.Interface of []string) - 
     * @param "NameNic" (optional.Interface of []string) - 
     * @param "NameNie" (optional.Interface of []string) - 
     * @param "NameNiew" (optional.Interface of []string) - 
     * @param "NameNire" (optional.Interface of []string) - 
     * @param "NameNisw" (optional.Interface of []string) - 
     * @param "NameNre" (optional.Interface of []string) - 
     * @param "NameRe" (optional.Interface of []string) - 
     * @param "NocContact" (optional.Interface of []string) - 
     * @param "NocContactIc" (optional.Interface of []string) - 
     * @param "NocContactIe" (optional.Interface of []string) - 
     * @param "NocContactIew" (optional.Interface of []string) - 
     * @param "NocContactIre" (optional.Interface of []string) - 
     * @param "NocContactIsw" (optional.Interface of []string) - 
     * @param "NocContactN" (optional.Interface of []string) - 
     * @param "NocContactNic" (optional.Interface of []string) - 
     * @param "NocContactNie" (optional.Interface of []string) - 
     * @param "NocContactNiew" (optional.Interface of []string) - 
     * @param "NocContactNire" (optional.Interface of []string) - 
     * @param "NocContactNisw" (optional.Interface of []string) - 
     * @param "NocContactNre" (optional.Interface of []string) - 
     * @param "NocContactRe" (optional.Interface of []string) - 
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "PortalUrl" (optional.Interface of []string) - 
     * @param "PortalUrlIc" (optional.Interface of []string) - 
     * @param "PortalUrlIe" (optional.Interface of []string) - 
     * @param "PortalUrlIew" (optional.Interface of []string) - 
     * @param "PortalUrlIre" (optional.Interface of []string) - 
     * @param "PortalUrlIsw" (optional.Interface of []string) - 
     * @param "PortalUrlN" (optional.Interface of []string) - 
     * @param "PortalUrlNic" (optional.Interface of []string) - 
     * @param "PortalUrlNie" (optional.Interface of []string) - 
     * @param "PortalUrlNiew" (optional.Interface of []string) - 
     * @param "PortalUrlNire" (optional.Interface of []string) - 
     * @param "PortalUrlNisw" (optional.Interface of []string) - 
     * @param "PortalUrlNre" (optional.Interface of []string) - 
     * @param "PortalUrlRe" (optional.Interface of []string) - 
     * @param "ProviderNetworks" (optional.Interface of []string) - 
     * @param "ProviderNetworksIsnull" (optional.Bool) - 
     * @param "ProviderNetworksN" (optional.Interface of []string) - 
     * @param "Q" (optional.String) -  Search
     * @param "Sort" (optional.String) -  Which field to use when ordering the results.
     * @param "Tags" (optional.Interface of []string) - 
     * @param "TagsIsnull" (optional.Bool) - 
     * @param "TagsN" (optional.Interface of []string) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedProviderList
*/

type CircuitsApiCircuitsProvidersListOpts struct {
    Account optional.Interface
    AccountIc optional.Interface
    AccountIe optional.Interface
    AccountIew optional.Interface
    AccountIre optional.Interface
    AccountIsw optional.Interface
    AccountN optional.Interface
    AccountNic optional.Interface
    AccountNie optional.Interface
    AccountNiew optional.Interface
    AccountNire optional.Interface
    AccountNisw optional.Interface
    AccountNre optional.Interface
    AccountRe optional.Interface
    AdminContact optional.Interface
    AdminContactIc optional.Interface
    AdminContactIe optional.Interface
    AdminContactIew optional.Interface
    AdminContactIre optional.Interface
    AdminContactIsw optional.Interface
    AdminContactN optional.Interface
    AdminContactNic optional.Interface
    AdminContactNie optional.Interface
    AdminContactNiew optional.Interface
    AdminContactNire optional.Interface
    AdminContactNisw optional.Interface
    AdminContactNre optional.Interface
    AdminContactRe optional.Interface
    Asn optional.Interface
    AsnGt optional.Interface
    AsnGte optional.Interface
    AsnIsnull optional.Bool
    AsnLt optional.Interface
    AsnLte optional.Interface
    AsnN optional.Interface
    Circuits optional.Interface
    CircuitsIsnull optional.Bool
    CircuitsN optional.Interface
    Comments optional.Interface
    CommentsIc optional.Interface
    CommentsIe optional.Interface
    CommentsIew optional.Interface
    CommentsIre optional.Interface
    CommentsIsw optional.Interface
    CommentsN optional.Interface
    CommentsNic optional.Interface
    CommentsNie optional.Interface
    CommentsNiew optional.Interface
    CommentsNire optional.Interface
    CommentsNisw optional.Interface
    CommentsNre optional.Interface
    CommentsRe optional.Interface
    Created optional.Interface
    CreatedGt optional.Interface
    CreatedGte optional.Interface
    CreatedIsnull optional.Bool
    CreatedLt optional.Interface
    CreatedLte optional.Interface
    CreatedN optional.Interface
    Format optional.String
    HasCircuits optional.Bool
    HasProviderNetworks optional.Bool
    Id optional.Interface
    IdIc optional.Interface
    IdIe optional.Interface
    IdIew optional.Interface
    IdIre optional.Interface
    IdIsw optional.Interface
    IdN optional.Interface
    IdNic optional.Interface
    IdNie optional.Interface
    IdNiew optional.Interface
    IdNire optional.Interface
    IdNisw optional.Interface
    IdNre optional.Interface
    IdRe optional.Interface
    LastUpdated optional.Interface
    LastUpdatedGt optional.Interface
    LastUpdatedGte optional.Interface
    LastUpdatedIsnull optional.Bool
    LastUpdatedLt optional.Interface
    LastUpdatedLte optional.Interface
    LastUpdatedN optional.Interface
    Limit optional.Int32
    Location optional.Interface
    LocationIsnull optional.Bool
    LocationN optional.Interface
    Name optional.Interface
    NameIc optional.Interface
    NameIe optional.Interface
    NameIew optional.Interface
    NameIre optional.Interface
    NameIsw optional.Interface
    NameN optional.Interface
    NameNic optional.Interface
    NameNie optional.Interface
    NameNiew optional.Interface
    NameNire optional.Interface
    NameNisw optional.Interface
    NameNre optional.Interface
    NameRe optional.Interface
    NocContact optional.Interface
    NocContactIc optional.Interface
    NocContactIe optional.Interface
    NocContactIew optional.Interface
    NocContactIre optional.Interface
    NocContactIsw optional.Interface
    NocContactN optional.Interface
    NocContactNic optional.Interface
    NocContactNie optional.Interface
    NocContactNiew optional.Interface
    NocContactNire optional.Interface
    NocContactNisw optional.Interface
    NocContactNre optional.Interface
    NocContactRe optional.Interface
    Offset optional.Int32
    PortalUrl optional.Interface
    PortalUrlIc optional.Interface
    PortalUrlIe optional.Interface
    PortalUrlIew optional.Interface
    PortalUrlIre optional.Interface
    PortalUrlIsw optional.Interface
    PortalUrlN optional.Interface
    PortalUrlNic optional.Interface
    PortalUrlNie optional.Interface
    PortalUrlNiew optional.Interface
    PortalUrlNire optional.Interface
    PortalUrlNisw optional.Interface
    PortalUrlNre optional.Interface
    PortalUrlRe optional.Interface
    ProviderNetworks optional.Interface
    ProviderNetworksIsnull optional.Bool
    ProviderNetworksN optional.Interface
    Q optional.String
    Sort optional.String
    Tags optional.Interface
    TagsIsnull optional.Bool
    TagsN optional.Interface
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProvidersList(ctx context.Context, localVarOptionals *CircuitsApiCircuitsProvidersListOpts) (PaginatedProviderList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedProviderList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Account.IsSet() {
		localVarQueryParams.Add("account", parameterToString(localVarOptionals.Account.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountIc.IsSet() {
		localVarQueryParams.Add("account__ic", parameterToString(localVarOptionals.AccountIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountIe.IsSet() {
		localVarQueryParams.Add("account__ie", parameterToString(localVarOptionals.AccountIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountIew.IsSet() {
		localVarQueryParams.Add("account__iew", parameterToString(localVarOptionals.AccountIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountIre.IsSet() {
		localVarQueryParams.Add("account__ire", parameterToString(localVarOptionals.AccountIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountIsw.IsSet() {
		localVarQueryParams.Add("account__isw", parameterToString(localVarOptionals.AccountIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountN.IsSet() {
		localVarQueryParams.Add("account__n", parameterToString(localVarOptionals.AccountN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNic.IsSet() {
		localVarQueryParams.Add("account__nic", parameterToString(localVarOptionals.AccountNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNie.IsSet() {
		localVarQueryParams.Add("account__nie", parameterToString(localVarOptionals.AccountNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNiew.IsSet() {
		localVarQueryParams.Add("account__niew", parameterToString(localVarOptionals.AccountNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNire.IsSet() {
		localVarQueryParams.Add("account__nire", parameterToString(localVarOptionals.AccountNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNisw.IsSet() {
		localVarQueryParams.Add("account__nisw", parameterToString(localVarOptionals.AccountNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNre.IsSet() {
		localVarQueryParams.Add("account__nre", parameterToString(localVarOptionals.AccountNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AccountRe.IsSet() {
		localVarQueryParams.Add("account__re", parameterToString(localVarOptionals.AccountRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContact.IsSet() {
		localVarQueryParams.Add("admin_contact", parameterToString(localVarOptionals.AdminContact.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactIc.IsSet() {
		localVarQueryParams.Add("admin_contact__ic", parameterToString(localVarOptionals.AdminContactIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactIe.IsSet() {
		localVarQueryParams.Add("admin_contact__ie", parameterToString(localVarOptionals.AdminContactIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactIew.IsSet() {
		localVarQueryParams.Add("admin_contact__iew", parameterToString(localVarOptionals.AdminContactIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactIre.IsSet() {
		localVarQueryParams.Add("admin_contact__ire", parameterToString(localVarOptionals.AdminContactIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactIsw.IsSet() {
		localVarQueryParams.Add("admin_contact__isw", parameterToString(localVarOptionals.AdminContactIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactN.IsSet() {
		localVarQueryParams.Add("admin_contact__n", parameterToString(localVarOptionals.AdminContactN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNic.IsSet() {
		localVarQueryParams.Add("admin_contact__nic", parameterToString(localVarOptionals.AdminContactNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNie.IsSet() {
		localVarQueryParams.Add("admin_contact__nie", parameterToString(localVarOptionals.AdminContactNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNiew.IsSet() {
		localVarQueryParams.Add("admin_contact__niew", parameterToString(localVarOptionals.AdminContactNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNire.IsSet() {
		localVarQueryParams.Add("admin_contact__nire", parameterToString(localVarOptionals.AdminContactNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNisw.IsSet() {
		localVarQueryParams.Add("admin_contact__nisw", parameterToString(localVarOptionals.AdminContactNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactNre.IsSet() {
		localVarQueryParams.Add("admin_contact__nre", parameterToString(localVarOptionals.AdminContactNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AdminContactRe.IsSet() {
		localVarQueryParams.Add("admin_contact__re", parameterToString(localVarOptionals.AdminContactRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Asn.IsSet() {
		localVarQueryParams.Add("asn", parameterToString(localVarOptionals.Asn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnGt.IsSet() {
		localVarQueryParams.Add("asn__gt", parameterToString(localVarOptionals.AsnGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnGte.IsSet() {
		localVarQueryParams.Add("asn__gte", parameterToString(localVarOptionals.AsnGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnIsnull.IsSet() {
		localVarQueryParams.Add("asn__isnull", parameterToString(localVarOptionals.AsnIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AsnLt.IsSet() {
		localVarQueryParams.Add("asn__lt", parameterToString(localVarOptionals.AsnLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnLte.IsSet() {
		localVarQueryParams.Add("asn__lte", parameterToString(localVarOptionals.AsnLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AsnN.IsSet() {
		localVarQueryParams.Add("asn__n", parameterToString(localVarOptionals.AsnN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Circuits.IsSet() {
		localVarQueryParams.Add("circuits", parameterToString(localVarOptionals.Circuits.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitsIsnull.IsSet() {
		localVarQueryParams.Add("circuits__isnull", parameterToString(localVarOptionals.CircuitsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CircuitsN.IsSet() {
		localVarQueryParams.Add("circuits__n", parameterToString(localVarOptionals.CircuitsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Comments.IsSet() {
		localVarQueryParams.Add("comments", parameterToString(localVarOptionals.Comments.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIc.IsSet() {
		localVarQueryParams.Add("comments__ic", parameterToString(localVarOptionals.CommentsIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIe.IsSet() {
		localVarQueryParams.Add("comments__ie", parameterToString(localVarOptionals.CommentsIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIew.IsSet() {
		localVarQueryParams.Add("comments__iew", parameterToString(localVarOptionals.CommentsIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIre.IsSet() {
		localVarQueryParams.Add("comments__ire", parameterToString(localVarOptionals.CommentsIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsIsw.IsSet() {
		localVarQueryParams.Add("comments__isw", parameterToString(localVarOptionals.CommentsIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsN.IsSet() {
		localVarQueryParams.Add("comments__n", parameterToString(localVarOptionals.CommentsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNic.IsSet() {
		localVarQueryParams.Add("comments__nic", parameterToString(localVarOptionals.CommentsNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNie.IsSet() {
		localVarQueryParams.Add("comments__nie", parameterToString(localVarOptionals.CommentsNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNiew.IsSet() {
		localVarQueryParams.Add("comments__niew", parameterToString(localVarOptionals.CommentsNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNire.IsSet() {
		localVarQueryParams.Add("comments__nire", parameterToString(localVarOptionals.CommentsNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNisw.IsSet() {
		localVarQueryParams.Add("comments__nisw", parameterToString(localVarOptionals.CommentsNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsNre.IsSet() {
		localVarQueryParams.Add("comments__nre", parameterToString(localVarOptionals.CommentsNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CommentsRe.IsSet() {
		localVarQueryParams.Add("comments__re", parameterToString(localVarOptionals.CommentsRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Created.IsSet() {
		localVarQueryParams.Add("created", parameterToString(localVarOptionals.Created.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGt.IsSet() {
		localVarQueryParams.Add("created__gt", parameterToString(localVarOptionals.CreatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedGte.IsSet() {
		localVarQueryParams.Add("created__gte", parameterToString(localVarOptionals.CreatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedIsnull.IsSet() {
		localVarQueryParams.Add("created__isnull", parameterToString(localVarOptionals.CreatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLt.IsSet() {
		localVarQueryParams.Add("created__lt", parameterToString(localVarOptionals.CreatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedLte.IsSet() {
		localVarQueryParams.Add("created__lte", parameterToString(localVarOptionals.CreatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedN.IsSet() {
		localVarQueryParams.Add("created__n", parameterToString(localVarOptionals.CreatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasCircuits.IsSet() {
		localVarQueryParams.Add("has_circuits", parameterToString(localVarOptionals.HasCircuits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasProviderNetworks.IsSet() {
		localVarQueryParams.Add("has_provider_networks", parameterToString(localVarOptionals.HasProviderNetworks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIc.IsSet() {
		localVarQueryParams.Add("id__ic", parameterToString(localVarOptionals.IdIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIe.IsSet() {
		localVarQueryParams.Add("id__ie", parameterToString(localVarOptionals.IdIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIew.IsSet() {
		localVarQueryParams.Add("id__iew", parameterToString(localVarOptionals.IdIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIre.IsSet() {
		localVarQueryParams.Add("id__ire", parameterToString(localVarOptionals.IdIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdIsw.IsSet() {
		localVarQueryParams.Add("id__isw", parameterToString(localVarOptionals.IdIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNic.IsSet() {
		localVarQueryParams.Add("id__nic", parameterToString(localVarOptionals.IdNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNie.IsSet() {
		localVarQueryParams.Add("id__nie", parameterToString(localVarOptionals.IdNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNiew.IsSet() {
		localVarQueryParams.Add("id__niew", parameterToString(localVarOptionals.IdNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNire.IsSet() {
		localVarQueryParams.Add("id__nire", parameterToString(localVarOptionals.IdNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNisw.IsSet() {
		localVarQueryParams.Add("id__nisw", parameterToString(localVarOptionals.IdNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdNre.IsSet() {
		localVarQueryParams.Add("id__nre", parameterToString(localVarOptionals.IdNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IdRe.IsSet() {
		localVarQueryParams.Add("id__re", parameterToString(localVarOptionals.IdRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdated.IsSet() {
		localVarQueryParams.Add("last_updated", parameterToString(localVarOptionals.LastUpdated.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated__gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGte.IsSet() {
		localVarQueryParams.Add("last_updated__gte", parameterToString(localVarOptionals.LastUpdatedGte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedIsnull.IsSet() {
		localVarQueryParams.Add("last_updated__isnull", parameterToString(localVarOptionals.LastUpdatedIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated__lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLte.IsSet() {
		localVarQueryParams.Add("last_updated__lte", parameterToString(localVarOptionals.LastUpdatedLte.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedN.IsSet() {
		localVarQueryParams.Add("last_updated__n", parameterToString(localVarOptionals.LastUpdatedN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIsnull.IsSet() {
		localVarQueryParams.Add("location__isnull", parameterToString(localVarOptionals.LocationIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationN.IsSet() {
		localVarQueryParams.Add("location__n", parameterToString(localVarOptionals.LocationN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIre.IsSet() {
		localVarQueryParams.Add("name__ire", parameterToString(localVarOptionals.NameIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNire.IsSet() {
		localVarQueryParams.Add("name__nire", parameterToString(localVarOptionals.NameNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNre.IsSet() {
		localVarQueryParams.Add("name__nre", parameterToString(localVarOptionals.NameNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameRe.IsSet() {
		localVarQueryParams.Add("name__re", parameterToString(localVarOptionals.NameRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContact.IsSet() {
		localVarQueryParams.Add("noc_contact", parameterToString(localVarOptionals.NocContact.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactIc.IsSet() {
		localVarQueryParams.Add("noc_contact__ic", parameterToString(localVarOptionals.NocContactIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactIe.IsSet() {
		localVarQueryParams.Add("noc_contact__ie", parameterToString(localVarOptionals.NocContactIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactIew.IsSet() {
		localVarQueryParams.Add("noc_contact__iew", parameterToString(localVarOptionals.NocContactIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactIre.IsSet() {
		localVarQueryParams.Add("noc_contact__ire", parameterToString(localVarOptionals.NocContactIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactIsw.IsSet() {
		localVarQueryParams.Add("noc_contact__isw", parameterToString(localVarOptionals.NocContactIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactN.IsSet() {
		localVarQueryParams.Add("noc_contact__n", parameterToString(localVarOptionals.NocContactN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNic.IsSet() {
		localVarQueryParams.Add("noc_contact__nic", parameterToString(localVarOptionals.NocContactNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNie.IsSet() {
		localVarQueryParams.Add("noc_contact__nie", parameterToString(localVarOptionals.NocContactNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNiew.IsSet() {
		localVarQueryParams.Add("noc_contact__niew", parameterToString(localVarOptionals.NocContactNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNire.IsSet() {
		localVarQueryParams.Add("noc_contact__nire", parameterToString(localVarOptionals.NocContactNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNisw.IsSet() {
		localVarQueryParams.Add("noc_contact__nisw", parameterToString(localVarOptionals.NocContactNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactNre.IsSet() {
		localVarQueryParams.Add("noc_contact__nre", parameterToString(localVarOptionals.NocContactNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NocContactRe.IsSet() {
		localVarQueryParams.Add("noc_contact__re", parameterToString(localVarOptionals.NocContactRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrl.IsSet() {
		localVarQueryParams.Add("portal_url", parameterToString(localVarOptionals.PortalUrl.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlIc.IsSet() {
		localVarQueryParams.Add("portal_url__ic", parameterToString(localVarOptionals.PortalUrlIc.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlIe.IsSet() {
		localVarQueryParams.Add("portal_url__ie", parameterToString(localVarOptionals.PortalUrlIe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlIew.IsSet() {
		localVarQueryParams.Add("portal_url__iew", parameterToString(localVarOptionals.PortalUrlIew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlIre.IsSet() {
		localVarQueryParams.Add("portal_url__ire", parameterToString(localVarOptionals.PortalUrlIre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlIsw.IsSet() {
		localVarQueryParams.Add("portal_url__isw", parameterToString(localVarOptionals.PortalUrlIsw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlN.IsSet() {
		localVarQueryParams.Add("portal_url__n", parameterToString(localVarOptionals.PortalUrlN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNic.IsSet() {
		localVarQueryParams.Add("portal_url__nic", parameterToString(localVarOptionals.PortalUrlNic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNie.IsSet() {
		localVarQueryParams.Add("portal_url__nie", parameterToString(localVarOptionals.PortalUrlNie.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNiew.IsSet() {
		localVarQueryParams.Add("portal_url__niew", parameterToString(localVarOptionals.PortalUrlNiew.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNire.IsSet() {
		localVarQueryParams.Add("portal_url__nire", parameterToString(localVarOptionals.PortalUrlNire.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNisw.IsSet() {
		localVarQueryParams.Add("portal_url__nisw", parameterToString(localVarOptionals.PortalUrlNisw.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlNre.IsSet() {
		localVarQueryParams.Add("portal_url__nre", parameterToString(localVarOptionals.PortalUrlNre.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PortalUrlRe.IsSet() {
		localVarQueryParams.Add("portal_url__re", parameterToString(localVarOptionals.PortalUrlRe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworks.IsSet() {
		localVarQueryParams.Add("provider_networks", parameterToString(localVarOptionals.ProviderNetworks.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworksIsnull.IsSet() {
		localVarQueryParams.Add("provider_networks__isnull", parameterToString(localVarOptionals.ProviderNetworksIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderNetworksN.IsSet() {
		localVarQueryParams.Add("provider_networks__n", parameterToString(localVarOptionals.ProviderNetworksN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.TagsIsnull.IsSet() {
		localVarQueryParams.Add("tags__isnull", parameterToString(localVarOptionals.TagsIsnull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsN.IsSet() {
		localVarQueryParams.Add("tags__n", parameterToString(localVarOptionals.TagsN.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedProviderList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersNotesCreateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Note
*/

type CircuitsApiCircuitsProvidersNotesCreateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersNotesCreate(ctx context.Context, body NoteInputRequest, id string, localVarOptionals *CircuitsApiCircuitsProvidersNotesCreateOpts) (Note, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Note
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 201 {
			var v Note
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
API methods for returning or creating notes on an object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersNotesListOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return PaginatedNoteList
*/

type CircuitsApiCircuitsProvidersNotesListOpts struct {
    Format optional.String
    Limit optional.Int32
    Offset optional.Int32
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProvidersNotesList(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProvidersNotesListOpts) (PaginatedNoteList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PaginatedNoteList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PaginatedNoteList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Partial update a provider object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersPartialUpdateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of PatchedProviderRequest) - 
     * @param "Format" (optional.String) - 
@return Provider
*/

type CircuitsApiCircuitsProvidersPartialUpdateOpts struct {
    Body optional.Interface
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersPartialUpdate(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProvidersPartialUpdateOpts) (Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Retrieve a provider object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersRetrieveOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
     * @param "Depth" (optional.Int32) -  Serializer Depth
@return Provider
*/

type CircuitsApiCircuitsProvidersRetrieveOpts struct {
    Format optional.String
    Depth optional.Int32
}

func (a *CircuitsApiService) CircuitsProvidersRetrieve(ctx context.Context, id string, localVarOptionals *CircuitsApiCircuitsProvidersRetrieveOpts) (Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarQueryParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CircuitsApiService
Update a provider object.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param id A UUID string identifying this provider.
 * @param optional nil or *CircuitsApiCircuitsProvidersUpdateOpts - Optional Parameters:
     * @param "Format" (optional.String) - 
@return Provider
*/

type CircuitsApiCircuitsProvidersUpdateOpts struct {
    Format optional.String
}

func (a *CircuitsApiService) CircuitsProvidersUpdate(ctx context.Context, body ProviderRequest, id string, localVarOptionals *CircuitsApiCircuitsProvidersUpdateOpts) (Provider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Provider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "text/csv"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("sessionid", key)
		}
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Provider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
